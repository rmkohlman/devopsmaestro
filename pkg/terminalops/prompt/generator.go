// Package prompt provides types and utilities for terminal prompt management.
package prompt

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/pelletier/go-toml/v2"
)

// StarshipGenerator generates starship.toml configuration files.
type StarshipGenerator struct{}

// NewStarshipGenerator creates a new StarshipGenerator.
func NewStarshipGenerator() *StarshipGenerator {
	return &StarshipGenerator{}
}

// Generate creates a starship.toml configuration from a Prompt.
func (g *StarshipGenerator) Generate(p *Prompt) (string, error) {
	if p == nil {
		return "", fmt.Errorf("prompt is nil")
	}
	if p.Type != PromptTypeStarship {
		return "", fmt.Errorf("prompt type must be starship, got %s", p.Type)
	}

	// If raw config is provided, use it directly
	if p.RawConfig != "" {
		return p.RawConfig, nil
	}

	// Build the configuration map
	config := make(map[string]any)

	// Add format if specified
	if p.Format != "" {
		config["format"] = p.Format
	}

	// Add character configuration
	if p.Character != nil {
		char := make(map[string]any)
		if p.Character.SuccessSymbol != "" {
			char["success_symbol"] = p.Character.SuccessSymbol
		}
		if p.Character.ErrorSymbol != "" {
			char["error_symbol"] = p.Character.ErrorSymbol
		}
		if p.Character.ViCmdSymbol != "" {
			char["vicmd_symbol"] = p.Character.ViCmdSymbol
		}
		if p.Character.ViInsSymbol != "" {
			char["vimcmd_symbol"] = p.Character.ViInsSymbol
		}
		if len(char) > 0 {
			config["character"] = char
		}
	}

	// Add module configurations
	for name, module := range p.Modules {
		modConfig := make(map[string]any)

		if module.Disabled {
			modConfig["disabled"] = true
		}
		if module.Format != "" {
			modConfig["format"] = module.Format
		}
		if module.Style != "" {
			modConfig["style"] = module.Style
		}
		if module.Symbol != "" {
			modConfig["symbol"] = module.Symbol
		}

		// Add additional options
		for k, v := range module.Options {
			modConfig[k] = v
		}

		if len(modConfig) > 0 {
			config[name] = modConfig
		}
	}

	// Add palette colors if specified
	if len(p.Colors) > 0 {
		palettes := make(map[string]map[string]string)
		palettes["custom"] = p.Colors
		config["palettes"] = palettes
		config["palette"] = "custom"
	}

	// Generate TOML
	data, err := toml.Marshal(config)
	if err != nil {
		return "", fmt.Errorf("failed to generate TOML: %w", err)
	}

	// Add header comment
	header := fmt.Sprintf("# Starship configuration generated by DevOpsMaestro\n# Prompt: %s\n# Description: %s\n\n",
		p.Name, p.Description)

	return header + string(data), nil
}

// WriteToFile generates starship configuration and writes it to the specified path.
// If outputPath is empty, returns an error (no default path for workspace isolation).
// The outputPath should be a directory where starship.toml will be created.
func (g *StarshipGenerator) WriteToFile(p *Prompt, outputPath string) error {
	if outputPath == "" {
		return fmt.Errorf("outputPath is required (no default path for workspace isolation)")
	}

	// Generate the starship configuration content
	config, err := g.Generate(p)
	if err != nil {
		return fmt.Errorf("failed to generate starship config: %w", err)
	}

	// Create the directory if it doesn't exist
	if err := os.MkdirAll(outputPath, 0700); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Write the file
	fullPath := filepath.Join(outputPath, "starship.toml")
	if err := os.WriteFile(fullPath, []byte(config), 0600); err != nil {
		return fmt.Errorf("failed to write starship config to %s: %w", fullPath, err)
	}

	return nil
}

// GenerateMinimal creates a minimal starship.toml with just the essentials.
func (g *StarshipGenerator) GenerateMinimal() string {
	return `# Minimal Starship configuration
# Generated by DevOpsMaestro

format = "$directory$git_branch$character"

[directory]
truncation_length = 3
truncate_to_repo = true

[git_branch]
format = "[$branch]($style) "
style = "bold purple"

[character]
success_symbol = "[❯](bold green)"
error_symbol = "[❯](bold red)"
`
}

// DefaultModules returns the default Starship modules configuration.
func DefaultModules() map[string]ModuleConfig {
	return map[string]ModuleConfig{
		"directory": {
			Options: map[string]any{
				"truncation_length": 3,
				"truncate_to_repo":  true,
			},
		},
		"git_branch": {
			Format: "[$branch]($style) ",
			Style:  "bold purple",
		},
		"git_status": {
			Format: "[$all_status$ahead_behind]($style) ",
		},
		"golang": {
			Symbol: " ",
		},
		"nodejs": {
			Symbol: " ",
		},
		"python": {
			Symbol: " ",
		},
		"rust": {
			Symbol: " ",
		},
		"docker_context": {
			Symbol: " ",
		},
		"kubernetes": {
			Disabled: true, // Disabled by default, can be verbose
		},
	}
}

// FormatWithColors applies color styling to a format string.
// Example: FormatWithColors("❯", "green") returns "[❯](green)"
func FormatWithColors(text, color string) string {
	if color == "" {
		return text
	}
	return fmt.Sprintf("[%s](%s)", text, color)
}

// BuildFormat constructs a Starship format string from module names.
// Example: BuildFormat("directory", "git_branch", "character") returns "$directory$git_branch$character"
func BuildFormat(modules ...string) string {
	var parts []string
	for _, m := range modules {
		parts = append(parts, "$"+m)
	}
	return strings.Join(parts, "")
}
