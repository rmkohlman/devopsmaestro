package prompt

import (
	"strings"
	"testing"

	"devopsmaestro/pkg/palette"
	"github.com/pelletier/go-toml/v2"
)

func TestStarshipRenderer_Render(t *testing.T) {
	tests := []struct {
		name       string
		prompt     *PromptYAML
		palette    *palette.Palette
		wantErr    bool
		wantChecks []string // Strings that should be in the output
	}{
		{
			name: "basic prompt with theme vars",
			prompt: &PromptYAML{
				APIVersion: "devopsmaestro.io/v1",
				Kind:       KindTerminalPrompt,
				Metadata: PromptMetadata{
					Name:        "test-prompt",
					Description: "A test prompt",
				},
				Spec: PromptSpec{
					Type:       PromptTypeStarship,
					AddNewline: true,
					Palette:    "theme",
					Format:     "[](${theme.red})$os",
					Modules: map[string]ModuleConfig{
						"os": {
							Disabled: false,
							Style:    "bg:${theme.red} fg:${theme.bg}",
						},
					},
				},
			},
			palette: &palette.Palette{
				Name: "coolnight",
				Colors: map[string]string{
					"bg":       "#1a1b26",
					"fg":       "#c0caf5",
					"red":      "#f7768e",
					"ansi_red": "#f7768e",
				},
			},
			wantErr: false,
			wantChecks: []string{
				"# Generated by dvm",
				"# Prompt: test-prompt",
				"# Theme: coolnight",
				"palette = 'coolnight'",
				"add_newline = true",
				"[palettes.coolnight]",
				"[os]",
				"disabled = false",
				"#f7768e", // resolved theme.red
				"#1a1b26", // resolved theme.bg
			},
		},
		{
			name: "prompt with multiple modules",
			prompt: &PromptYAML{
				APIVersion: "devopsmaestro.io/v1",
				Kind:       KindTerminalPrompt,
				Metadata: PromptMetadata{
					Name: "multi-module",
				},
				Spec: PromptSpec{
					Type:       PromptTypeStarship,
					AddNewline: false,
					Modules: map[string]ModuleConfig{
						"directory": {
							Style: "bg:${theme.yellow}",
							Options: map[string]any{
								"truncation_length": 3,
							},
						},
						"git_branch": {
							Style:  "bg:${theme.cyan}",
							Symbol: " ",
						},
					},
				},
			},
			palette: &palette.Palette{
				Name: "tokyonight",
				Colors: map[string]string{
					"ansi_yellow": "#e0af68",
					"ansi_cyan":   "#7dcfff",
				},
			},
			wantErr: false,
			wantChecks: []string{
				"add_newline = false",
				"[directory]",
				"truncation_length = 3",
				"[git_branch]",
				"symbol = \" \"",
			},
		},
		{
			name:    "nil prompt returns error",
			prompt:  nil,
			palette: &palette.Palette{Name: "test"},
			wantErr: true,
		},
		{
			name: "nil palette returns error",
			prompt: &PromptYAML{
				Metadata: PromptMetadata{Name: "test"},
			},
			palette: nil,
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := NewRenderer()
			got, err := r.Render(tt.prompt, tt.palette)

			if (err != nil) != tt.wantErr {
				t.Errorf("Render() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if tt.wantErr {
				return
			}

			for _, check := range tt.wantChecks {
				if !strings.Contains(got, check) {
					t.Errorf("Render() output missing expected string %q\nGot:\n%s", check, got)
				}
			}
		})
	}
}

func TestStarshipRenderer_resolveThemeVars(t *testing.T) {
	r := NewRenderer()
	pal := &palette.Palette{
		Name: "test",
		Colors: map[string]string{
			"bg":         "#000000",
			"fg":         "#ffffff",
			"ansi_red":   "#ff0000",
			"ansi_green": "#00ff00",
			"ansi_blue":  "#0000ff",
			"primary":    "#7aa2f7",
		},
	}

	tests := []struct {
		name  string
		input string
		want  string
	}{
		{
			name:  "single variable",
			input: "${theme.bg}",
			want:  "#000000",
		},
		{
			name:  "multiple variables",
			input: "bg:${theme.red} fg:${theme.bg}",
			want:  "bg:#ff0000 fg:#000000",
		},
		{
			name:  "variable in format string",
			input: "[](${theme.primary})$os[](bg:${theme.green})",
			want:  "[](#7aa2f7)$os[](bg:#00ff00)",
		},
		{
			name:  "no variables",
			input: "bg:#123456 fg:#654321",
			want:  "bg:#123456 fg:#654321",
		},
		{
			name:  "unknown variable unchanged",
			input: "${theme.nonexistent}",
			want:  "${theme.nonexistent}",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := r.resolveThemeVars(tt.input, pal)
			if got != tt.want {
				t.Errorf("resolveThemeVars() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestNewTerminalPrompt(t *testing.T) {
	prompt := NewTerminalPrompt("my-prompt")

	if prompt.APIVersion != "devopsmaestro.io/v1" {
		t.Errorf("NewTerminalPrompt() APIVersion = %q, want %q", prompt.APIVersion, "devopsmaestro.io/v1")
	}

	if prompt.Kind != KindTerminalPrompt {
		t.Errorf("NewTerminalPrompt() Kind = %q, want %q", prompt.Kind, KindTerminalPrompt)
	}

	if prompt.Metadata.Name != "my-prompt" {
		t.Errorf("NewTerminalPrompt() Name = %q, want %q", prompt.Metadata.Name, "my-prompt")
	}

	if prompt.Spec.AddNewline != true {
		t.Errorf("NewTerminalPrompt() AddNewline = %v, want true", prompt.Spec.AddNewline)
	}

	if prompt.Spec.Palette != "theme" {
		t.Errorf("NewTerminalPrompt() Palette = %q, want %q", prompt.Spec.Palette, "theme")
	}

	if prompt.Spec.Type != PromptTypeStarship {
		t.Errorf("NewTerminalPrompt() Type = %q, want %q", prompt.Spec.Type, PromptTypeStarship)
	}
}

func TestPromptYAML_ResourceInterface(t *testing.T) {
	prompt := NewTerminalPrompt("test-prompt")

	if prompt.GetKind() != KindTerminalPrompt {
		t.Errorf("GetKind() = %q, want %q", prompt.GetKind(), KindTerminalPrompt)
	}

	if prompt.GetName() != "test-prompt" {
		t.Errorf("GetName() = %q, want %q", prompt.GetName(), "test-prompt")
	}

	if prompt.GetAPIVersion() != "devopsmaestro.io/v1" {
		t.Errorf("GetAPIVersion() = %q, want %q", prompt.GetAPIVersion(), "devopsmaestro.io/v1")
	}
}

// TestEscapeTOMLString tests the escapeTOMLString function directly
func TestEscapeTOMLString(t *testing.T) {
	tests := []struct {
		name  string
		input string
		want  string
	}{
		{
			name:  "string with double quotes",
			input: `echo "hello"`,
			want:  `echo \"hello\"`,
		},
		{
			name:  "string with brackets (should remain unchanged)",
			input: `echo '[api]'`,
			want:  `echo '[api]'`,
		},
		{
			name:  "string with backslashes",
			input: `path\to\file`,
			want:  `path\\to\\file`,
		},
		{
			name:  "string with both quotes and backslashes",
			input: `echo "c:\path"`,
			want:  `echo \"c:\\path\"`,
		},
		{
			name:  "empty string",
			input: "",
			want:  "",
		},
		{
			name:  "string with no special chars",
			input: "hello world",
			want:  "hello world",
		},
		{
			name:  "complex case with runbook brackets",
			input: `echo '[runbook-api]'`,
			want:  `echo '[runbook-api]'`,
		},
		{
			name:  "mixed quotes and brackets",
			input: `echo "[runbook-api]"`,
			want:  `echo \"[runbook-api]\"`,
		},
		{
			name:  "backslash before quote",
			input: `path\"quoted`,
			want:  `path\\\"quoted`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := escapeTOMLString(tt.input)
			if got != tt.want {
				t.Errorf("escapeTOMLString(%q) = %q, want %q", tt.input, got, tt.want)
			}
		})
	}
}

// TestTOMLStringEscapingInGeneration tests that generated TOML is valid and parseable
func TestTOMLStringEscapingInGeneration(t *testing.T) {
	tests := []struct {
		name          string
		command       string
		wantParseable bool
		wantValue     string
	}{
		{
			name:          "command with brackets",
			command:       `echo '[runbook-api]'`,
			wantParseable: true,
			wantValue:     `echo '[runbook-api]'`,
		},
		{
			name:          "command with double quotes",
			command:       `echo "hello world"`,
			wantParseable: true,
			wantValue:     `echo "hello world"`,
		},
		{
			name:          "command with backslashes",
			command:       `C:\path\to\file.exe`,
			wantParseable: true,
			wantValue:     `C:\path\to\file.exe`,
		},
		{
			name:          "command with both quotes and backslashes",
			command:       `echo "C:\Program Files\app"`,
			wantParseable: true,
			wantValue:     `echo "C:\Program Files\app"`,
		},
		{
			name:          "complex command with multiple special chars",
			command:       `bash -c "grep '[api]' /path/to/file"`,
			wantParseable: true,
			wantValue:     `bash -c "grep '[api]' /path/to/file"`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a TerminalPrompt with a custom_command module
			prompt := &PromptYAML{
				APIVersion: "devopsmaestro.io/v1",
				Kind:       KindTerminalPrompt,
				Metadata: PromptMetadata{
					Name: "test-escaping",
				},
				Spec: PromptSpec{
					Type:       PromptTypeStarship,
					AddNewline: true,
					Modules: map[string]ModuleConfig{
						"custom": {
							Options: map[string]any{
								"command": tt.command,
							},
						},
					},
				},
			}

			// Create a simple palette
			pal := &palette.Palette{
				Name: "test",
				Colors: map[string]string{
					"bg": "#000000",
					"fg": "#ffffff",
				},
			}

			// Render the TOML
			renderer := NewRenderer()
			tomlContent, err := renderer.Render(prompt, pal)
			if err != nil {
				t.Fatalf("Failed to render TOML: %v", err)
			}

			// Try to parse the generated TOML
			var parsed map[string]any
			err = toml.Unmarshal([]byte(tomlContent), &parsed)

			if tt.wantParseable {
				if err != nil {
					t.Errorf("Generated TOML should be parseable but got error: %v\nGenerated TOML:\n%s", err, tomlContent)
					return
				}

				// Verify the parsed value matches the original
				customSection, ok := parsed["custom"].(map[string]any)
				if !ok {
					t.Errorf("Expected custom section in parsed TOML, got: %+v", parsed)
					return
				}

				if command, ok := customSection["command"].(string); ok {
					if command != tt.wantValue {
						t.Errorf("Parsed command value = %q, want %q", command, tt.wantValue)
					}
				} else {
					t.Errorf("Expected command field in custom section, got: %+v", customSection)
				}
			} else {
				if err == nil {
					t.Errorf("Expected TOML parsing to fail but it succeeded")
				}
			}
		})
	}
}

// TestTOMLStringEscapingInArrays tests escaping in array values
func TestTOMLStringEscapingInArrays(t *testing.T) {
	prompt := &PromptYAML{
		APIVersion: "devopsmaestro.io/v1",
		Kind:       KindTerminalPrompt,
		Metadata: PromptMetadata{
			Name: "test-array-escaping",
		},
		Spec: PromptSpec{
			Type:       PromptTypeStarship,
			AddNewline: true,
			Modules: map[string]ModuleConfig{
				"custom": {
					Options: map[string]any{
						"commands": []string{
							`echo '[api-1]'`,
							`echo "hello"`,
							`path\to\file`,
						},
					},
				},
			},
		},
	}

	pal := &palette.Palette{
		Name: "test",
		Colors: map[string]string{
			"bg": "#000000",
		},
	}

	renderer := NewRenderer()
	tomlContent, err := renderer.Render(prompt, pal)
	if err != nil {
		t.Fatalf("Failed to render TOML: %v", err)
	}

	// Parse the generated TOML
	var parsed map[string]any
	err = toml.Unmarshal([]byte(tomlContent), &parsed)
	if err != nil {
		t.Errorf("Generated TOML should be parseable but got error: %v\nGenerated TOML:\n%s", err, tomlContent)
		return
	}

	// Verify the parsed array values match the originals
	customSection, ok := parsed["custom"].(map[string]any)
	if !ok {
		t.Errorf("Expected custom section in parsed TOML")
		return
	}

	commands, ok := customSection["commands"].([]any)
	if !ok {
		t.Errorf("Expected commands array in custom section")
		return
	}

	expectedCommands := []string{
		`echo '[api-1]'`,
		`echo "hello"`,
		`path\to\file`,
	}

	if len(commands) != len(expectedCommands) {
		t.Errorf("Expected %d commands, got %d", len(expectedCommands), len(commands))
		return
	}

	for i, expected := range expectedCommands {
		if actual, ok := commands[i].(string); ok {
			if actual != expected {
				t.Errorf("Command[%d] = %q, want %q", i, actual, expected)
			}
		} else {
			t.Errorf("Command[%d] is not a string: %v", i, commands[i])
		}
	}
}
