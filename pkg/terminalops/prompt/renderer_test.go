package prompt

import (
	"strings"
	"testing"

	"devopsmaestro/pkg/palette"
)

func TestStarshipRenderer_Render(t *testing.T) {
	tests := []struct {
		name       string
		prompt     *PromptYAML
		palette    *palette.Palette
		wantErr    bool
		wantChecks []string // Strings that should be in the output
	}{
		{
			name: "basic prompt with theme vars",
			prompt: &PromptYAML{
				APIVersion: "devopsmaestro.io/v1",
				Kind:       KindTerminalPrompt,
				Metadata: PromptMetadata{
					Name:        "test-prompt",
					Description: "A test prompt",
				},
				Spec: PromptSpec{
					Type:       PromptTypeStarship,
					AddNewline: true,
					Palette:    "theme",
					Format:     "[](${theme.red})$os",
					Modules: map[string]ModuleConfig{
						"os": {
							Disabled: false,
							Style:    "bg:${theme.red} fg:${theme.bg}",
						},
					},
				},
			},
			palette: &palette.Palette{
				Name: "coolnight",
				Colors: map[string]string{
					"bg":       "#1a1b26",
					"fg":       "#c0caf5",
					"red":      "#f7768e",
					"ansi_red": "#f7768e",
				},
			},
			wantErr: false,
			wantChecks: []string{
				"# Generated by dvm",
				"# Prompt: test-prompt",
				"# Theme: coolnight",
				"palette = 'coolnight'",
				"add_newline = true",
				"[palettes.coolnight]",
				"[os]",
				"disabled = false",
				"#f7768e", // resolved theme.red
				"#1a1b26", // resolved theme.bg
			},
		},
		{
			name: "prompt with multiple modules",
			prompt: &PromptYAML{
				APIVersion: "devopsmaestro.io/v1",
				Kind:       KindTerminalPrompt,
				Metadata: PromptMetadata{
					Name: "multi-module",
				},
				Spec: PromptSpec{
					Type:       PromptTypeStarship,
					AddNewline: false,
					Modules: map[string]ModuleConfig{
						"directory": {
							Style: "bg:${theme.yellow}",
							Options: map[string]any{
								"truncation_length": 3,
							},
						},
						"git_branch": {
							Style:  "bg:${theme.cyan}",
							Symbol: " ",
						},
					},
				},
			},
			palette: &palette.Palette{
				Name: "tokyonight",
				Colors: map[string]string{
					"ansi_yellow": "#e0af68",
					"ansi_cyan":   "#7dcfff",
				},
			},
			wantErr: false,
			wantChecks: []string{
				"add_newline = false",
				"[directory]",
				"truncation_length = 3",
				"[git_branch]",
				"symbol = \" \"",
			},
		},
		{
			name:    "nil prompt returns error",
			prompt:  nil,
			palette: &palette.Palette{Name: "test"},
			wantErr: true,
		},
		{
			name: "nil palette returns error",
			prompt: &PromptYAML{
				Metadata: PromptMetadata{Name: "test"},
			},
			palette: nil,
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := NewRenderer()
			got, err := r.Render(tt.prompt, tt.palette)

			if (err != nil) != tt.wantErr {
				t.Errorf("Render() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if tt.wantErr {
				return
			}

			for _, check := range tt.wantChecks {
				if !strings.Contains(got, check) {
					t.Errorf("Render() output missing expected string %q\nGot:\n%s", check, got)
				}
			}
		})
	}
}

func TestStarshipRenderer_resolveThemeVars(t *testing.T) {
	r := NewRenderer()
	pal := &palette.Palette{
		Name: "test",
		Colors: map[string]string{
			"bg":         "#000000",
			"fg":         "#ffffff",
			"ansi_red":   "#ff0000",
			"ansi_green": "#00ff00",
			"ansi_blue":  "#0000ff",
			"primary":    "#7aa2f7",
		},
	}

	tests := []struct {
		name  string
		input string
		want  string
	}{
		{
			name:  "single variable",
			input: "${theme.bg}",
			want:  "#000000",
		},
		{
			name:  "multiple variables",
			input: "bg:${theme.red} fg:${theme.bg}",
			want:  "bg:#ff0000 fg:#000000",
		},
		{
			name:  "variable in format string",
			input: "[](${theme.primary})$os[](bg:${theme.green})",
			want:  "[](#7aa2f7)$os[](bg:#00ff00)",
		},
		{
			name:  "no variables",
			input: "bg:#123456 fg:#654321",
			want:  "bg:#123456 fg:#654321",
		},
		{
			name:  "unknown variable unchanged",
			input: "${theme.nonexistent}",
			want:  "${theme.nonexistent}",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := r.resolveThemeVars(tt.input, pal)
			if got != tt.want {
				t.Errorf("resolveThemeVars() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestNewTerminalPrompt(t *testing.T) {
	prompt := NewTerminalPrompt("my-prompt")

	if prompt.APIVersion != "devopsmaestro.io/v1" {
		t.Errorf("NewTerminalPrompt() APIVersion = %q, want %q", prompt.APIVersion, "devopsmaestro.io/v1")
	}

	if prompt.Kind != KindTerminalPrompt {
		t.Errorf("NewTerminalPrompt() Kind = %q, want %q", prompt.Kind, KindTerminalPrompt)
	}

	if prompt.Metadata.Name != "my-prompt" {
		t.Errorf("NewTerminalPrompt() Name = %q, want %q", prompt.Metadata.Name, "my-prompt")
	}

	if prompt.Spec.AddNewline != true {
		t.Errorf("NewTerminalPrompt() AddNewline = %v, want true", prompt.Spec.AddNewline)
	}

	if prompt.Spec.Palette != "theme" {
		t.Errorf("NewTerminalPrompt() Palette = %q, want %q", prompt.Spec.Palette, "theme")
	}

	if prompt.Spec.Type != PromptTypeStarship {
		t.Errorf("NewTerminalPrompt() Type = %q, want %q", prompt.Spec.Type, PromptTypeStarship)
	}
}

func TestPromptYAML_ResourceInterface(t *testing.T) {
	prompt := NewTerminalPrompt("test-prompt")

	if prompt.GetKind() != KindTerminalPrompt {
		t.Errorf("GetKind() = %q, want %q", prompt.GetKind(), KindTerminalPrompt)
	}

	if prompt.GetName() != "test-prompt" {
		t.Errorf("GetName() = %q, want %q", prompt.GetName(), "test-prompt")
	}

	if prompt.GetAPIVersion() != "devopsmaestro.io/v1" {
		t.Errorf("GetAPIVersion() = %q, want %q", prompt.GetAPIVersion(), "devopsmaestro.io/v1")
	}
}
