// Package plugin provides types and utilities for shell plugin management.
package plugin

import (
	"fmt"
	"sort"
	"strings"
)

// ZshGenerator generates .zshrc plugin configuration.
type ZshGenerator struct {
	// PluginDir is where plugins will be installed
	PluginDir string
}

// NewZshGenerator creates a new ZshGenerator.
func NewZshGenerator(pluginDir string) *ZshGenerator {
	if pluginDir == "" {
		pluginDir = "${HOME}/.local/share/zsh/plugins"
	}
	return &ZshGenerator{PluginDir: pluginDir}
}

// Generate creates zsh configuration for loading plugins.
func (g *ZshGenerator) Generate(plugins []*Plugin) (string, error) {
	if len(plugins) == 0 {
		return "# No terminal plugins configured\n", nil
	}

	// Sort by priority (lower first)
	sorted := make([]*Plugin, len(plugins))
	copy(sorted, plugins)
	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i].Priority < sorted[j].Priority
	})

	var sb strings.Builder
	sb.WriteString("# Terminal plugins generated by DevOpsMaestro\n")
	sb.WriteString(fmt.Sprintf("# Plugin directory: %s\n\n", g.PluginDir))

	// Group by manager
	byManager := make(map[PluginManager][]*Plugin)
	for _, p := range sorted {
		if !p.Enabled {
			continue
		}
		byManager[p.Manager] = append(byManager[p.Manager], p)
	}

	// Generate for each manager
	if plugins := byManager[PluginManagerManual]; len(plugins) > 0 {
		sb.WriteString(g.generateManual(plugins))
	}
	if plugins := byManager[PluginManagerZinit]; len(plugins) > 0 {
		sb.WriteString(g.generateZinit(plugins))
	}
	if plugins := byManager[PluginManagerOhMyZsh]; len(plugins) > 0 {
		sb.WriteString(g.generateOhMyZsh(plugins))
	}
	if plugins := byManager[PluginManagerAntigen]; len(plugins) > 0 {
		sb.WriteString(g.generateAntigen(plugins))
	}
	if plugins := byManager[PluginManagerSheldon]; len(plugins) > 0 {
		sb.WriteString(g.generateSheldon(plugins))
	}

	return sb.String(), nil
}

// generateManual generates manual git clone + source approach.
func (g *ZshGenerator) generateManual(plugins []*Plugin) string {
	var sb strings.Builder
	sb.WriteString("# === Manual plugin loading ===\n")
	sb.WriteString(fmt.Sprintf("PLUGIN_DIR=\"%s\"\n", g.PluginDir))
	sb.WriteString("mkdir -p \"$PLUGIN_DIR\"\n\n")

	for _, p := range plugins {
		sb.WriteString(fmt.Sprintf("# %s\n", p.Name))
		if p.Description != "" {
			sb.WriteString(fmt.Sprintf("# %s\n", p.Description))
		}

		// Set environment variables first
		for k, v := range p.Env {
			sb.WriteString(fmt.Sprintf("export %s=\"%s\"\n", k, v))
		}

		pluginPath := fmt.Sprintf("$PLUGIN_DIR/%s", p.Name)

		// Clone if not exists
		if p.Repo != "" {
			sb.WriteString(fmt.Sprintf("if [[ ! -d \"%s\" ]]; then\n", pluginPath))
			cloneCmd := fmt.Sprintf("  git clone --depth=1")
			if p.Branch != "" {
				cloneCmd += fmt.Sprintf(" -b %s", p.Branch)
			}
			cloneCmd += fmt.Sprintf(" https://github.com/%s \"%s\"\n", p.Repo, pluginPath)
			sb.WriteString(cloneCmd)
			sb.WriteString("fi\n")
		}

		// Source the plugin
		if len(p.SourceFiles) > 0 {
			for _, f := range p.SourceFiles {
				sb.WriteString(fmt.Sprintf("source \"%s/%s\"\n", pluginPath, f))
			}
		} else {
			// Auto-detect common patterns
			sb.WriteString(fmt.Sprintf("for f in \"%s\"/*.plugin.zsh \"%s\"/*.zsh; do\n", pluginPath, pluginPath))
			sb.WriteString("  [[ -f \"$f\" ]] && source \"$f\" && break\n")
			sb.WriteString("done\n")
		}

		// Run config
		if p.Config != "" {
			sb.WriteString(p.Config)
			sb.WriteString("\n")
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

// generateZinit generates Zinit plugin manager configuration.
func (g *ZshGenerator) generateZinit(plugins []*Plugin) string {
	var sb strings.Builder
	sb.WriteString("# === Zinit plugins ===\n")
	sb.WriteString("# Ensure zinit is installed\n")
	sb.WriteString("if [[ ! -f \"${ZINIT_HOME:-$HOME/.local/share/zinit/zinit.git}/zinit.zsh\" ]]; then\n")
	sb.WriteString("  command mkdir -p \"${ZINIT_HOME:-$HOME/.local/share/zinit/zinit.git}\"\n")
	sb.WriteString("  command git clone https://github.com/zdharma-continuum/zinit \"${ZINIT_HOME:-$HOME/.local/share/zinit/zinit.git}\"\n")
	sb.WriteString("fi\n")
	sb.WriteString("source \"${ZINIT_HOME:-$HOME/.local/share/zinit/zinit.git}/zinit.zsh\"\n\n")

	for _, p := range plugins {
		sb.WriteString(fmt.Sprintf("# %s\n", p.Name))

		// Set environment variables
		for k, v := range p.Env {
			sb.WriteString(fmt.Sprintf("export %s=\"%s\"\n", k, v))
		}

		// Zinit ice modifiers
		var ice []string
		switch p.LoadMode {
		case LoadModeDeferred:
			ice = append(ice, "wait\"0\"", "lucid")
		case LoadModeLazy:
			ice = append(ice, "wait\"1\"", "lucid")
		}
		if p.Branch != "" {
			ice = append(ice, fmt.Sprintf("ver\"%s\"", p.Branch))
		}

		if len(ice) > 0 {
			sb.WriteString(fmt.Sprintf("zinit ice %s\n", strings.Join(ice, " ")))
		}

		// Load command
		if p.Repo != "" {
			sb.WriteString(fmt.Sprintf("zinit light %s\n", p.Repo))
		}

		if p.Config != "" {
			sb.WriteString(p.Config)
			sb.WriteString("\n")
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

// generateOhMyZsh generates Oh My Zsh configuration.
func (g *ZshGenerator) generateOhMyZsh(plugins []*Plugin) string {
	var sb strings.Builder
	sb.WriteString("# === Oh My Zsh plugins ===\n")

	var pluginNames []string
	var customPlugins []*Plugin

	for _, p := range plugins {
		// Set environment variables
		for k, v := range p.Env {
			sb.WriteString(fmt.Sprintf("export %s=\"%s\"\n", k, v))
		}

		if p.OhMyZshPlugin != "" {
			// Built-in oh-my-zsh plugin
			pluginNames = append(pluginNames, p.OhMyZshPlugin)
		} else if p.Repo != "" {
			// Custom plugin to clone to custom/plugins
			customPlugins = append(customPlugins, p)
		}
	}

	// Clone custom plugins
	if len(customPlugins) > 0 {
		sb.WriteString("\n# Custom plugins (clone to $ZSH_CUSTOM/plugins)\n")
		for _, p := range customPlugins {
			pluginPath := fmt.Sprintf("${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/%s", p.Name)
			sb.WriteString(fmt.Sprintf("if [[ ! -d \"%s\" ]]; then\n", pluginPath))
			sb.WriteString(fmt.Sprintf("  git clone --depth=1 https://github.com/%s \"%s\"\n", p.Repo, pluginPath))
			sb.WriteString("fi\n")
			pluginNames = append(pluginNames, p.Name)
		}
	}

	// Output plugins array
	sb.WriteString("\n# Add to plugins array in .zshrc:\n")
	sb.WriteString(fmt.Sprintf("plugins=(%s)\n", strings.Join(pluginNames, " ")))

	return sb.String()
}

// generateAntigen generates Antigen configuration.
func (g *ZshGenerator) generateAntigen(plugins []*Plugin) string {
	var sb strings.Builder
	sb.WriteString("# === Antigen plugins ===\n")
	sb.WriteString("# Ensure antigen is installed and sourced\n")
	sb.WriteString("# source /path/to/antigen.zsh\n\n")

	for _, p := range plugins {
		// Set environment variables
		for k, v := range p.Env {
			sb.WriteString(fmt.Sprintf("export %s=\"%s\"\n", k, v))
		}

		if p.Repo != "" {
			branch := ""
			if p.Branch != "" {
				branch = fmt.Sprintf(" --branch=%s", p.Branch)
			}
			sb.WriteString(fmt.Sprintf("antigen bundle %s%s\n", p.Repo, branch))
		} else if p.OhMyZshPlugin != "" {
			sb.WriteString(fmt.Sprintf("antigen bundle %s\n", p.OhMyZshPlugin))
		}

		if p.Config != "" {
			sb.WriteString(p.Config)
			sb.WriteString("\n")
		}
	}

	sb.WriteString("\nantigen apply\n")
	return sb.String()
}

// generateSheldon generates Sheldon plugin manager configuration (TOML).
func (g *ZshGenerator) generateSheldon(plugins []*Plugin) string {
	var sb strings.Builder
	sb.WriteString("# === Sheldon plugins ===\n")
	sb.WriteString("# Add to ~/.config/sheldon/plugins.toml:\n\n")

	for _, p := range plugins {
		sb.WriteString(fmt.Sprintf("[plugins.%s]\n", p.Name))
		if p.Repo != "" {
			sb.WriteString(fmt.Sprintf("github = \"%s\"\n", p.Repo))
		} else if p.Source != "" {
			sb.WriteString(fmt.Sprintf("remote = \"%s\"\n", p.Source))
		}
		if p.Branch != "" {
			sb.WriteString(fmt.Sprintf("branch = \"%s\"\n", p.Branch))
		}
		if p.Tag != "" {
			sb.WriteString(fmt.Sprintf("tag = \"%s\"\n", p.Tag))
		}
		sb.WriteString("\n")
	}

	sb.WriteString("# Then run: eval \"$(sheldon source)\"\n")
	return sb.String()
}

// GenerateInstallScript generates a shell script to install all plugins.
func (g *ZshGenerator) GenerateInstallScript(plugins []*Plugin) string {
	var sb strings.Builder
	sb.WriteString("#!/bin/bash\n")
	sb.WriteString("# Plugin installation script generated by DevOpsMaestro\n")
	sb.WriteString("set -e\n\n")
	sb.WriteString(fmt.Sprintf("PLUGIN_DIR=\"%s\"\n", g.PluginDir))
	sb.WriteString("mkdir -p \"$PLUGIN_DIR\"\n\n")

	for _, p := range plugins {
		if !p.Enabled || p.Repo == "" {
			continue
		}

		sb.WriteString(fmt.Sprintf("echo \"Installing %s...\"\n", p.Name))
		pluginPath := fmt.Sprintf("$PLUGIN_DIR/%s", p.Name)
		sb.WriteString(fmt.Sprintf("if [[ -d \"%s\" ]]; then\n", pluginPath))
		sb.WriteString(fmt.Sprintf("  echo \"  %s already installed, updating...\"\n", p.Name))
		sb.WriteString(fmt.Sprintf("  (cd \"%s\" && git pull --quiet)\n", pluginPath))
		sb.WriteString("else\n")
		cloneCmd := "  git clone --depth=1"
		if p.Branch != "" {
			cloneCmd += fmt.Sprintf(" -b %s", p.Branch)
		}
		cloneCmd += fmt.Sprintf(" https://github.com/%s \"%s\"\n", p.Repo, pluginPath)
		sb.WriteString(cloneCmd)
		sb.WriteString("fi\n\n")
	}

	sb.WriteString("echo \"All plugins installed!\"\n")
	return sb.String()
}
