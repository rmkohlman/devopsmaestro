// Package shell provides types and utilities for shell configuration management.
package shell

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// Generator generates shell configuration files.
type Generator struct{}

// NewGenerator creates a new shell configuration Generator.
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate creates shell configuration for the given Shell.
func (g *Generator) Generate(s *Shell) (string, error) {
	if s == nil {
		return "", fmt.Errorf("shell is nil")
	}
	if !s.Enabled {
		return "# Shell configuration disabled\n", nil
	}

	switch s.ShellType {
	case ShellTypeZsh:
		return g.generateZsh(s)
	case ShellTypeBash:
		return g.generateBash(s)
	case ShellTypeFish:
		return g.generateFish(s)
	default:
		return "", fmt.Errorf("unsupported shell type: %s", s.ShellType)
	}
}

// WriteToFile generates shell configuration and writes it to the specified path.
// If outputPath is empty, returns an error (no default path for workspace isolation).
// The outputPath should be a directory where the shell config file will be created.
// The filename is determined by the shell type (e.g., .zshrc.workspace, .bashrc.workspace).
func (g *Generator) WriteToFile(s *Shell, outputPath string) error {
	if outputPath == "" {
		return fmt.Errorf("outputPath is required (no default path for workspace isolation)")
	}

	// Generate the shell configuration content
	config, err := g.Generate(s)
	if err != nil {
		return fmt.Errorf("failed to generate shell config: %w", err)
	}

	// Create the directory if it doesn't exist
	if err := os.MkdirAll(outputPath, 0700); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Determine filename based on shell type
	var filename string
	switch s.ShellType {
	case ShellTypeZsh:
		filename = ".zshrc.workspace"
	case ShellTypeBash:
		filename = ".bashrc.workspace"
	case ShellTypeFish:
		filename = "config.fish.workspace"
	default:
		filename = fmt.Sprintf(".%src.workspace", s.ShellType)
	}

	// Write the file
	fullPath := filepath.Join(outputPath, filename)
	if err := os.WriteFile(fullPath, []byte(config), 0600); err != nil {
		return fmt.Errorf("failed to write shell config to %s: %w", fullPath, err)
	}

	return nil
}

// generateZsh generates zsh configuration.
func (g *Generator) generateZsh(s *Shell) (string, error) {
	var sb strings.Builder
	sb.WriteString("# Shell configuration generated by DevOpsMaestro\n")
	sb.WriteString(fmt.Sprintf("# Name: %s\n", s.Name))
	if s.Description != "" {
		sb.WriteString(fmt.Sprintf("# %s\n", s.Description))
	}
	sb.WriteString("\n")

	// Shell options
	if len(s.Options) > 0 {
		sb.WriteString("# === Shell Options ===\n")
		for _, opt := range s.Options {
			sb.WriteString(fmt.Sprintf("setopt %s\n", opt))
		}
		sb.WriteString("\n")
	}

	// History configuration
	if s.History != nil {
		sb.WriteString("# === History Configuration ===\n")
		if s.History.Size > 0 {
			sb.WriteString(fmt.Sprintf("HISTSIZE=%d\n", s.History.Size))
			sb.WriteString(fmt.Sprintf("SAVEHIST=%d\n", s.History.Size))
		}
		if s.History.File != "" {
			sb.WriteString(fmt.Sprintf("HISTFILE=\"%s\"\n", s.History.File))
		}
		if s.History.IgnoreDups {
			sb.WriteString("setopt HIST_IGNORE_ALL_DUPS\n")
		}
		if s.History.IgnoreSpace {
			sb.WriteString("setopt HIST_IGNORE_SPACE\n")
		}
		if s.History.ShareHistory {
			sb.WriteString("setopt SHARE_HISTORY\n")
		}
		if s.History.ExtendedFormat {
			sb.WriteString("setopt EXTENDED_HISTORY\n")
		}
		sb.WriteString("\n")
	}

	// PATH modifications
	if len(s.PathPrepend) > 0 || len(s.PathAppend) > 0 {
		sb.WriteString("# === PATH Modifications ===\n")
		for _, p := range s.PathPrepend {
			sb.WriteString(fmt.Sprintf("export PATH=\"%s:$PATH\"\n", p))
		}
		for _, p := range s.PathAppend {
			sb.WriteString(fmt.Sprintf("export PATH=\"$PATH:%s\"\n", p))
		}
		sb.WriteString("\n")
	}

	// Environment variables
	if len(s.Env) > 0 {
		sb.WriteString("# === Environment Variables ===\n")
		for _, env := range s.Env {
			if env.Description != "" {
				sb.WriteString(fmt.Sprintf("# %s\n", env.Description))
			}
			if env.Expand {
				sb.WriteString(fmt.Sprintf("export %s=\"%s\"\n", env.Name, env.Value))
			} else {
				sb.WriteString(fmt.Sprintf("export %s='%s'\n", env.Name, env.Value))
			}
		}
		sb.WriteString("\n")
	}

	// Aliases
	if len(s.Aliases) > 0 {
		sb.WriteString("# === Aliases ===\n")
		for _, alias := range s.Aliases {
			if alias.Description != "" {
				sb.WriteString(fmt.Sprintf("# %s\n", alias.Description))
			}
			if alias.Global {
				sb.WriteString(fmt.Sprintf("alias -g %s='%s'\n", alias.Name, alias.Command))
			} else {
				sb.WriteString(fmt.Sprintf("alias %s='%s'\n", alias.Name, alias.Command))
			}
		}
		sb.WriteString("\n")
	}

	// Functions
	if len(s.Functions) > 0 {
		sb.WriteString("# === Functions ===\n")
		for _, fn := range s.Functions {
			if fn.Description != "" {
				sb.WriteString(fmt.Sprintf("# %s\n", fn.Description))
			}
			sb.WriteString(fmt.Sprintf("%s() {\n", fn.Name))
			// Indent function body
			lines := strings.Split(fn.Body, "\n")
			for _, line := range lines {
				sb.WriteString(fmt.Sprintf("  %s\n", line))
			}
			sb.WriteString("}\n\n")
		}
	}

	// Keybindings
	if len(s.Keybindings) > 0 {
		sb.WriteString("# === Keybindings ===\n")
		for _, kb := range s.Keybindings {
			if kb.Description != "" {
				sb.WriteString(fmt.Sprintf("# %s\n", kb.Description))
			}
			if kb.Widget != "" {
				sb.WriteString(fmt.Sprintf("bindkey '%s' %s\n", kb.Key, kb.Widget))
			} else if kb.Command != "" {
				// Create a widget for the command
				widgetName := strings.ReplaceAll(kb.Key, "^", "ctrl-")
				widgetName = strings.ReplaceAll(widgetName, "[", "")
				widgetName = strings.ReplaceAll(widgetName, "]", "")
				sb.WriteString(fmt.Sprintf("%s-widget() { %s }\n", widgetName, kb.Command))
				sb.WriteString(fmt.Sprintf("zle -N %s-widget\n", widgetName))
				sb.WriteString(fmt.Sprintf("bindkey '%s' %s-widget\n", kb.Key, widgetName))
			}
		}
		sb.WriteString("\n")
	}

	// Raw config (escape hatch)
	if s.RawConfig != "" {
		sb.WriteString("# === Custom Configuration ===\n")
		sb.WriteString(s.RawConfig)
		sb.WriteString("\n")
	}

	return sb.String(), nil
}

// generateBash generates bash configuration.
func (g *Generator) generateBash(s *Shell) (string, error) {
	var sb strings.Builder
	sb.WriteString("# Shell configuration generated by DevOpsMaestro\n")
	sb.WriteString(fmt.Sprintf("# Name: %s\n", s.Name))
	if s.Description != "" {
		sb.WriteString(fmt.Sprintf("# %s\n", s.Description))
	}
	sb.WriteString("\n")

	// Shell options
	if len(s.Options) > 0 {
		sb.WriteString("# === Shell Options ===\n")
		for _, opt := range s.Options {
			sb.WriteString(fmt.Sprintf("shopt -s %s\n", strings.ToLower(opt)))
		}
		sb.WriteString("\n")
	}

	// History configuration
	if s.History != nil {
		sb.WriteString("# === History Configuration ===\n")
		if s.History.Size > 0 {
			sb.WriteString(fmt.Sprintf("HISTSIZE=%d\n", s.History.Size))
			sb.WriteString(fmt.Sprintf("HISTFILESIZE=%d\n", s.History.Size))
		}
		if s.History.File != "" {
			sb.WriteString(fmt.Sprintf("HISTFILE=\"%s\"\n", s.History.File))
		}
		if s.History.IgnoreDups {
			sb.WriteString("HISTCONTROL=ignoredups:erasedups\n")
		}
		if s.History.IgnoreSpace {
			sb.WriteString("HISTCONTROL=${HISTCONTROL}:ignorespace\n")
		}
		if s.History.ShareHistory {
			sb.WriteString("shopt -s histappend\n")
			sb.WriteString("PROMPT_COMMAND=\"history -a; history -c; history -r; $PROMPT_COMMAND\"\n")
		}
		sb.WriteString("\n")
	}

	// PATH modifications
	if len(s.PathPrepend) > 0 || len(s.PathAppend) > 0 {
		sb.WriteString("# === PATH Modifications ===\n")
		for _, p := range s.PathPrepend {
			sb.WriteString(fmt.Sprintf("export PATH=\"%s:$PATH\"\n", p))
		}
		for _, p := range s.PathAppend {
			sb.WriteString(fmt.Sprintf("export PATH=\"$PATH:%s\"\n", p))
		}
		sb.WriteString("\n")
	}

	// Environment variables
	if len(s.Env) > 0 {
		sb.WriteString("# === Environment Variables ===\n")
		for _, env := range s.Env {
			if env.Description != "" {
				sb.WriteString(fmt.Sprintf("# %s\n", env.Description))
			}
			if env.Expand {
				sb.WriteString(fmt.Sprintf("export %s=\"%s\"\n", env.Name, env.Value))
			} else {
				sb.WriteString(fmt.Sprintf("export %s='%s'\n", env.Name, env.Value))
			}
		}
		sb.WriteString("\n")
	}

	// Aliases
	if len(s.Aliases) > 0 {
		sb.WriteString("# === Aliases ===\n")
		for _, alias := range s.Aliases {
			if alias.Description != "" {
				sb.WriteString(fmt.Sprintf("# %s\n", alias.Description))
			}
			sb.WriteString(fmt.Sprintf("alias %s='%s'\n", alias.Name, alias.Command))
		}
		sb.WriteString("\n")
	}

	// Functions
	if len(s.Functions) > 0 {
		sb.WriteString("# === Functions ===\n")
		for _, fn := range s.Functions {
			if fn.Description != "" {
				sb.WriteString(fmt.Sprintf("# %s\n", fn.Description))
			}
			sb.WriteString(fmt.Sprintf("%s() {\n", fn.Name))
			lines := strings.Split(fn.Body, "\n")
			for _, line := range lines {
				sb.WriteString(fmt.Sprintf("  %s\n", line))
			}
			sb.WriteString("}\n\n")
		}
	}

	// Raw config
	if s.RawConfig != "" {
		sb.WriteString("# === Custom Configuration ===\n")
		sb.WriteString(s.RawConfig)
		sb.WriteString("\n")
	}

	return sb.String(), nil
}

// generateFish generates fish shell configuration.
func (g *Generator) generateFish(s *Shell) (string, error) {
	var sb strings.Builder
	sb.WriteString("# Shell configuration generated by DevOpsMaestro\n")
	sb.WriteString(fmt.Sprintf("# Name: %s\n", s.Name))
	if s.Description != "" {
		sb.WriteString(fmt.Sprintf("# %s\n", s.Description))
	}
	sb.WriteString("\n")

	// PATH modifications (fish uses fish_add_path)
	if len(s.PathPrepend) > 0 || len(s.PathAppend) > 0 {
		sb.WriteString("# === PATH Modifications ===\n")
		for _, p := range s.PathPrepend {
			sb.WriteString(fmt.Sprintf("fish_add_path --prepend %s\n", p))
		}
		for _, p := range s.PathAppend {
			sb.WriteString(fmt.Sprintf("fish_add_path --append %s\n", p))
		}
		sb.WriteString("\n")
	}

	// Environment variables (fish uses set -gx)
	if len(s.Env) > 0 {
		sb.WriteString("# === Environment Variables ===\n")
		for _, env := range s.Env {
			if env.Description != "" {
				sb.WriteString(fmt.Sprintf("# %s\n", env.Description))
			}
			sb.WriteString(fmt.Sprintf("set -gx %s \"%s\"\n", env.Name, env.Value))
		}
		sb.WriteString("\n")
	}

	// Aliases (fish uses abbr or alias)
	if len(s.Aliases) > 0 {
		sb.WriteString("# === Aliases ===\n")
		for _, alias := range s.Aliases {
			if alias.Description != "" {
				sb.WriteString(fmt.Sprintf("# %s\n", alias.Description))
			}
			// Use abbreviations for fish (expand when typed)
			sb.WriteString(fmt.Sprintf("abbr -a %s '%s'\n", alias.Name, alias.Command))
		}
		sb.WriteString("\n")
	}

	// Functions
	if len(s.Functions) > 0 {
		sb.WriteString("# === Functions ===\n")
		for _, fn := range s.Functions {
			if fn.Description != "" {
				sb.WriteString(fmt.Sprintf("# %s\n", fn.Description))
			}
			sb.WriteString(fmt.Sprintf("function %s\n", fn.Name))
			lines := strings.Split(fn.Body, "\n")
			for _, line := range lines {
				sb.WriteString(fmt.Sprintf("  %s\n", line))
			}
			sb.WriteString("end\n\n")
		}
	}

	// Raw config
	if s.RawConfig != "" {
		sb.WriteString("# === Custom Configuration ===\n")
		sb.WriteString(s.RawConfig)
		sb.WriteString("\n")
	}

	return sb.String(), nil
}
