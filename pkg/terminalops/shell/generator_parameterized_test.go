package shell

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// =============================================================================
// Task 2.4: Parameterized Config Generator Tests (v0.19.0) - Terminalops
// Tests verify shell generators accept output path and never write to host
// =============================================================================

// TestShellConfigWithCustomOutputPath verifies generator accepts custom output path
func TestShellConfigWithCustomOutputPath(t *testing.T) {
	tempDir := t.TempDir()
	workspaceSlug := "test-eco-domain-app-ws"
	customOutputPath := filepath.Join(tempDir, ".devopsmaestro", "workspaces", workspaceSlug, ".dvm", "shell")

	shell := &Shell{
		Name:      "workspace-shell",
		ShellType: ShellTypeZsh,
		Enabled:   true,
	}

	gen := NewGenerator()

	// Generate shell config
	config, err := gen.Generate(shell)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	// FIXME: This test will FAIL - need WriteToFile or WriteToDirectory method
	// After Phase 3, generator should have:
	// func (g *Generator) WriteToFile(shell *Shell, outputPath string) error
	// Currently generators return string, not write to files

	// Create directory and write file manually for now (to test the concept)
	if err := os.MkdirAll(customOutputPath, 0700); err != nil {
		t.Fatalf("Setup error: %v", err)
	}

	outputFile := filepath.Join(customOutputPath, ".zshrc.workspace")
	if err := os.WriteFile(outputFile, []byte(config), 0600); err != nil {
		t.Fatalf("WriteFile error: %v", err)
	}

	// Verify file was written to custom path
	if _, err := os.Stat(outputFile); err != nil {
		t.Errorf("Expected shell config file not found at custom path: %v", err)
	}

	// Verify content is correct
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("ReadFile error: %v", err)
	}

	if !strings.Contains(string(content), "# Shell configuration generated by DevOpsMaestro") {
		t.Errorf("Shell config does not contain expected marker")
	}
}

// TestShellConfigWritesToWorkspacePath verifies writes go to workspace path
func TestShellConfigWritesToWorkspacePath(t *testing.T) {
	tempDir := t.TempDir()

	tests := []struct {
		name          string
		workspaceSlug string
		expectedPath  string
	}{
		{
			name:          "dev workspace",
			workspaceSlug: "personal-tools-dvm-dev",
			expectedPath:  ".devopsmaestro/workspaces/personal-tools-dvm-dev/.dvm/shell",
		},
		{
			name:          "production workspace",
			workspaceSlug: "enterprise-payments-api-prod",
			expectedPath:  ".devopsmaestro/workspaces/enterprise-payments-api-prod/.dvm/shell",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			outputPath := filepath.Join(tempDir, tt.expectedPath)

			shell := &Shell{
				Name:      "workspace-shell",
				ShellType: ShellTypeZsh,
				Enabled:   true,
			}

			gen := NewGenerator()
			config, err := gen.Generate(shell)
			if err != nil {
				t.Fatalf("Generate() error = %v", err)
			}

			// FIXME: After Phase 3, this should use WriteToFile(shell, outputPath)
			if err := os.MkdirAll(outputPath, 0700); err != nil {
				t.Fatalf("Setup error: %v", err)
			}

			outputFile := filepath.Join(outputPath, ".zshrc.workspace")
			if err := os.WriteFile(outputFile, []byte(config), 0600); err != nil {
				t.Fatalf("WriteFile error: %v", err)
			}

			// Verify output is in the workspace path
			if !strings.Contains(outputPath, tt.workspaceSlug) {
				t.Errorf("Output path %q does not contain workspace slug %q", outputPath, tt.workspaceSlug)
			}

			// Verify .dvm/shell subdirectory
			if !strings.HasSuffix(outputPath, ".dvm/shell") && !strings.HasSuffix(outputPath, ".dvm"+string(filepath.Separator)+"shell") {
				t.Errorf("Output path %q does not end with .dvm/shell", outputPath)
			}

			// Verify config file exists in workspace path
			if _, err := os.Stat(outputFile); err != nil {
				t.Errorf("Shell config not found in workspace path: %v", err)
			}
		})
	}
}

// TestShellConfigDoesNotWriteToHostPath verifies NEVER writes to ~/.zshrc
func TestShellConfigDoesNotWriteToHostPath(t *testing.T) {
	// Get user's home directory
	homeDir, err := os.UserHomeDir()
	if err != nil {
		t.Skipf("Cannot get home directory: %v", err)
	}

	hostZshrcPath := filepath.Join(homeDir, ".zshrc")
	hostZshrcDPath := filepath.Join(homeDir, ".zshrc.d")

	// Record initial state
	hostZshrcExists := false
	var hostZshrcModTime int64
	if info, err := os.Stat(hostZshrcPath); err == nil {
		hostZshrcExists = true
		hostZshrcModTime = info.ModTime().Unix()
	}

	hostZshrcDExists := false
	if _, err := os.Stat(hostZshrcDPath); err == nil {
		hostZshrcDExists = true
	}

	// Create workspace path
	tempDir := t.TempDir()
	workspacePath := filepath.Join(tempDir, ".devopsmaestro", "workspaces", "test-ws", ".dvm", "shell")

	shell := &Shell{
		Name:      "workspace-shell",
		ShellType: ShellTypeZsh,
		Enabled:   true,
	}

	gen := NewGenerator()
	config, err := gen.Generate(shell)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	// FIXME: After Phase 3, generators must use outputPath parameter
	// Currently testing the concept manually
	if err := os.MkdirAll(workspacePath, 0700); err != nil {
		t.Fatalf("Setup error: %v", err)
	}

	outputFile := filepath.Join(workspacePath, ".zshrc.workspace")
	if err := os.WriteFile(outputFile, []byte(config), 0600); err != nil {
		t.Fatalf("WriteFile error: %v", err)
	}

	// Verify host .zshrc was NOT touched
	if hostZshrcExists {
		info, err := os.Stat(hostZshrcPath)
		if err == nil {
			if info.ModTime().Unix() > hostZshrcModTime {
				t.Errorf("Host .zshrc %q was modified - generator leaked to host!", hostZshrcPath)
			}
		}
	} else {
		if _, err := os.Stat(hostZshrcPath); err == nil {
			t.Errorf("Host .zshrc %q was created - generator leaked to host!", hostZshrcPath)
		}
	}

	// Verify host .zshrc.d was NOT touched
	if !hostZshrcDExists {
		if _, err := os.Stat(hostZshrcDPath); err == nil {
			t.Errorf("Host .zshrc.d %q was created - generator leaked to host!", hostZshrcDPath)
		}
	}

	// Verify output went to workspace path
	if _, err := os.Stat(outputFile); err != nil {
		t.Errorf("Shell config not found in workspace path: %v", err)
	}

	// Verify NO DevOpsMaestro markers in host .zshrc
	if hostZshrcExists {
		content, err := os.ReadFile(hostZshrcPath)
		if err == nil {
			if strings.Contains(string(content), "DevOpsMaestro") || strings.Contains(string(content), "dvm workspace") {
				t.Errorf("Host .zshrc contains DevOpsMaestro markers - generator leaked!")
			}
		}
	}
}

// TestStarshipConfigWritesToWorkspacePath verifies starship config uses workspace path
func TestStarshipConfigWritesToWorkspacePath(t *testing.T) {
	tempDir := t.TempDir()
	workspaceSlug := "test-ws"
	starshipPath := filepath.Join(tempDir, ".devopsmaestro", "workspaces", workspaceSlug, ".dvm", "starship")

	// Create minimal starship config
	starshipContent := `# Starship configuration generated by DevOpsMaestro

[character]
success_symbol = "[➜](bold green)"
error_symbol = "[✗](bold red)"
`

	// FIXME: After Phase 3, should have StarshipGenerator with WriteToFile method
	// For now, testing the path structure
	if err := os.MkdirAll(starshipPath, 0700); err != nil {
		t.Fatalf("Setup error: %v", err)
	}

	outputFile := filepath.Join(starshipPath, "starship.toml")
	if err := os.WriteFile(outputFile, []byte(starshipContent), 0600); err != nil {
		t.Fatalf("WriteFile error: %v", err)
	}

	// Verify starship.toml is in workspace path
	if _, err := os.Stat(outputFile); err != nil {
		t.Errorf("starship.toml not found in workspace path: %v", err)
	}

	// Verify path contains workspace slug
	if !strings.Contains(outputFile, workspaceSlug) {
		t.Errorf("Starship config path %q does not contain workspace slug %q", outputFile, workspaceSlug)
	}

	// Verify .dvm/starship subdirectory
	if !strings.Contains(outputFile, ".dvm/starship") {
		t.Errorf("Starship config path %q does not contain .dvm/starship", outputFile)
	}
}

// TestStarshipConfigDoesNotWriteToHostPath verifies NEVER writes to ~/.config/starship.toml
func TestStarshipConfigDoesNotWriteToHostPath(t *testing.T) {
	// Get user's home directory
	homeDir, err := os.UserHomeDir()
	if err != nil {
		t.Skipf("Cannot get home directory: %v", err)
	}

	hostStarshipPath := filepath.Join(homeDir, ".config", "starship.toml")

	// Record initial state
	hostStarshipExists := false
	var hostStarshipModTime int64
	if info, err := os.Stat(hostStarshipPath); err == nil {
		hostStarshipExists = true
		hostStarshipModTime = info.ModTime().Unix()
	}

	// Create workspace path
	tempDir := t.TempDir()
	workspacePath := filepath.Join(tempDir, ".devopsmaestro", "workspaces", "test-ws", ".dvm", "starship")

	starshipContent := "# Workspace starship config\n"

	// FIXME: After Phase 3, generators must use outputPath parameter
	if err := os.MkdirAll(workspacePath, 0700); err != nil {
		t.Fatalf("Setup error: %v", err)
	}

	outputFile := filepath.Join(workspacePath, "starship.toml")
	if err := os.WriteFile(outputFile, []byte(starshipContent), 0600); err != nil {
		t.Fatalf("WriteFile error: %v", err)
	}

	// Verify host starship config was NOT touched
	if hostStarshipExists {
		info, err := os.Stat(hostStarshipPath)
		if err == nil {
			if info.ModTime().Unix() > hostStarshipModTime {
				t.Errorf("Host starship.toml %q was modified - generator leaked to host!", hostStarshipPath)
			}
		}
	} else {
		if _, err := os.Stat(hostStarshipPath); err == nil {
			t.Errorf("Host starship.toml %q was created - generator leaked to host!", hostStarshipPath)
		}
	}

	// Verify output went to workspace path
	if _, err := os.Stat(outputFile); err != nil {
		t.Errorf("Starship config not found in workspace path: %v", err)
	}
}

// TestShellGeneratorMultipleWorkspaces verifies each workspace gets isolated config
func TestShellGeneratorMultipleWorkspaces(t *testing.T) {
	tempDir := t.TempDir()

	workspaces := []struct {
		slug    string
		content string
	}{
		{slug: "workspace-1", content: "export WS=workspace-1\n"},
		{slug: "workspace-2", content: "export WS=workspace-2\n"},
	}

	gen := NewGenerator()

	for _, ws := range workspaces {
		shell := &Shell{
			Name:      "shell-" + ws.slug,
			ShellType: ShellTypeZsh,
			Enabled:   true,
		}

		config, err := gen.Generate(shell)
		if err != nil {
			t.Fatalf("Generate() for %s error = %v", ws.slug, err)
		}

		// Write to workspace-specific path
		outputPath := filepath.Join(tempDir, ".devopsmaestro", "workspaces", ws.slug, ".dvm", "shell")
		if err := os.MkdirAll(outputPath, 0700); err != nil {
			t.Fatalf("Setup error: %v", err)
		}

		outputFile := filepath.Join(outputPath, ".zshrc.workspace")
		if err := os.WriteFile(outputFile, []byte(config), 0600); err != nil {
			t.Fatalf("WriteFile error: %v", err)
		}
	}

	// Verify each workspace has its own isolated config
	for _, ws := range workspaces {
		outputFile := filepath.Join(tempDir, ".devopsmaestro", "workspaces", ws.slug, ".dvm", "shell", ".zshrc.workspace")

		if _, err := os.Stat(outputFile); err != nil {
			t.Errorf("Workspace %s config not found: %v", ws.slug, err)
		}

		// Verify configs are in different directories
		if !strings.Contains(outputFile, ws.slug) {
			t.Errorf("Config path %q does not contain workspace slug %q", outputFile, ws.slug)
		}
	}
}

// TestTerminalConfigPathParameter verifies all terminal config generators accept path
func TestTerminalConfigPathParameter(t *testing.T) {
	tests := []struct {
		name       string
		configType string
		filename   string
	}{
		{
			name:       "shell config",
			configType: "shell",
			filename:   ".zshrc.workspace",
		},
		{
			name:       "starship config",
			configType: "starship",
			filename:   "starship.toml",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tempDir := t.TempDir()
			workspacePath := filepath.Join(tempDir, ".devopsmaestro", "workspaces", "test-ws", ".dvm", tt.configType)

			// FIXME: After Phase 3, all config generators should accept outputPath
			// This test verifies the path structure is correct
			if err := os.MkdirAll(workspacePath, 0700); err != nil {
				t.Fatalf("Setup error: %v", err)
			}

			outputFile := filepath.Join(workspacePath, tt.filename)
			if err := os.WriteFile(outputFile, []byte("# test"), 0600); err != nil {
				t.Fatalf("WriteFile error: %v", err)
			}

			// Verify file is in workspace-specific path
			if !strings.Contains(outputFile, ".devopsmaestro/workspaces/test-ws") {
				t.Errorf("Output path %q is not in workspace-specific directory", outputFile)
			}

			// Verify subdirectory structure
			if !strings.Contains(outputFile, fmt.Sprintf(".dvm/%s", tt.configType)) {
				t.Errorf("Output path %q does not contain .dvm/%s", outputFile, tt.configType)
			}
		})
	}
}
