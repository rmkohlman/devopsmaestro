package theme

import (
	"fmt"
	"sort"
	"strings"
)

// Generator generates Lua code for themes.
type Generator struct{}

// NewGenerator creates a new theme Lua generator.
func NewGenerator() *Generator {
	return &Generator{}
}

// GeneratedTheme contains all generated Lua files for a theme.
type GeneratedTheme struct {
	// PaletteLua is the palette module (theme/palette.lua)
	PaletteLua string
	// InitLua is the theme setup (theme/init.lua)
	InitLua string
	// PluginLua is the lazy.nvim plugin spec (plugins/colorscheme.lua)
	PluginLua string
	// ColorschemeLua is the standalone colorscheme implementation (theme/colorscheme.lua)
	// Only populated for standalone themes
	ColorschemeLua string
}

// Generate generates all Lua files for a theme.
func (g *Generator) Generate(t *Theme) (*GeneratedTheme, error) {
	if err := t.Validate(); err != nil {
		return nil, err
	}

	palette, err := g.generatePalette(t)
	if err != nil {
		return nil, err
	}

	initLua, err := g.generateInit(t)
	if err != nil {
		return nil, err
	}

	pluginLua, err := g.generatePlugin(t)
	if err != nil {
		return nil, err
	}

	result := &GeneratedTheme{
		PaletteLua: palette,
		InitLua:    initLua,
		PluginLua:  pluginLua,
	}

	// Generate standalone colorscheme code if this is a standalone theme
	if t.IsStandalone() {
		colorschemeLua, err := g.generateStandaloneColorscheme(t)
		if err != nil {
			return nil, err
		}
		result.ColorschemeLua = colorschemeLua
	}

	return result, nil
}

// generatePalette generates the palette module that other plugins can require.
// Usage in other plugins: local palette = require("theme").palette
func (g *Generator) generatePalette(t *Theme) (string, error) {
	var sb strings.Builder

	sb.WriteString("-- Theme Palette: " + t.Name + "\n")
	sb.WriteString("-- This module exports theme colors for use by other plugins.\n")
	sb.WriteString("-- Usage: local palette = require(\"theme\").palette\n")
	sb.WriteString("-- Generated by nvp (NvimOps)\n\n")

	sb.WriteString("local M = {}\n\n")

	// Theme metadata
	sb.WriteString("-- Theme metadata\n")
	sb.WriteString(fmt.Sprintf("M.name = %q\n", t.Name))
	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("M.style = %q\n", t.Style))
	}
	sb.WriteString(fmt.Sprintf("M.transparent = %s\n", boolToLua(t.Transparent)))
	sb.WriteString("\n")

	// Colors palette
	sb.WriteString("-- Color palette\n")
	sb.WriteString("M.colors = {\n")

	// Sort keys for consistent output
	keys := make([]string, 0, len(t.Colors))
	for k := range t.Colors {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, key := range keys {
		sb.WriteString(fmt.Sprintf("  %s = %q,\n", key, t.Colors[key]))
	}
	sb.WriteString("}\n\n")

	// Semantic color aliases (common names that plugins expect)
	sb.WriteString("-- Semantic aliases for common plugin usage\n")
	sb.WriteString("M.semantic = {\n")
	g.writeSemanticAliases(&sb, t)
	sb.WriteString("}\n\n")

	// Helper function to get color with fallback
	sb.WriteString("-- Get a color with optional fallback\n")
	sb.WriteString("function M.get(name, fallback)\n")
	sb.WriteString("  return M.colors[name] or M.semantic[name] or fallback\n")
	sb.WriteString("end\n\n")

	// Helper to check if transparent mode
	sb.WriteString("-- Check if transparent mode is enabled\n")
	sb.WriteString("function M.is_transparent()\n")
	sb.WriteString("  return M.transparent\n")
	sb.WriteString("end\n\n")

	sb.WriteString("return M\n")

	return sb.String(), nil
}

// writeSemanticAliases maps theme colors to common semantic names
func (g *Generator) writeSemanticAliases(sb *strings.Builder, t *Theme) {
	// Map common color names to semantic meanings
	semanticMap := map[string][]string{
		"background":  {"bg", "bg_dark"},
		"foreground":  {"fg", "fg_dark"},
		"selection":   {"bg_visual", "bg_highlight"},
		"comment":     {"comment", "fg_gutter"},
		"border":      {"border", "fg_gutter"},
		"cursor_line": {"bg_highlight", "bg_visual"},
		"search":      {"bg_search", "bg_highlight"},
		"popup":       {"bg_popup", "bg_float", "bg_dark"},
		"sidebar":     {"bg_sidebar", "bg_dark"},
		"statusline":  {"bg_statusline", "bg_dark"},
		"error":       {"error", "red"},
		"warning":     {"warning", "yellow", "orange"},
		"info":        {"info", "blue", "cyan"},
		"hint":        {"hint", "cyan", "teal"},
		"success":     {"success", "green"},
		"added":       {"added", "git_add", "green"},
		"modified":    {"modified", "git_change", "blue", "yellow"},
		"removed":     {"removed", "git_delete", "red"},
	}

	for semantic, candidates := range semanticMap {
		for _, candidate := range candidates {
			if color, ok := t.Colors[candidate]; ok {
				sb.WriteString(fmt.Sprintf("  %s = %q,\n", semantic, color))
				break
			}
		}
	}
}

// generateInit generates the theme init module.
func (g *Generator) generateInit(t *Theme) (string, error) {
	var sb strings.Builder

	sb.WriteString("-- Theme: " + t.Name + "\n")
	if t.Description != "" {
		sb.WriteString("-- " + t.Description + "\n")
	}
	sb.WriteString("-- Generated by nvp (NvimOps)\n\n")

	sb.WriteString("local M = {}\n\n")

	// Re-export palette
	sb.WriteString("-- Re-export palette for easy access\n")
	sb.WriteString("M.palette = require(\"theme.palette\")\n\n")

	// Setup function that plugins can call
	sb.WriteString("-- Setup function (called automatically by colorscheme plugin)\n")
	sb.WriteString("function M.setup()\n")
	sb.WriteString("  -- Theme is configured via the colorscheme plugin\n")
	sb.WriteString("  -- This function is for any additional setup if needed\n")
	sb.WriteString("end\n\n")

	// Helper to apply highlights using palette
	sb.WriteString("-- Apply a highlight group using palette colors\n")
	sb.WriteString("function M.highlight(group, opts)\n")
	sb.WriteString("  local hl = {}\n")
	sb.WriteString("  if opts.fg then hl.fg = M.palette.get(opts.fg, opts.fg) end\n")
	sb.WriteString("  if opts.bg then hl.bg = M.palette.get(opts.bg, opts.bg) end\n")
	sb.WriteString("  if opts.sp then hl.sp = M.palette.get(opts.sp, opts.sp) end\n")
	sb.WriteString("  if opts.bold then hl.bold = true end\n")
	sb.WriteString("  if opts.italic then hl.italic = true end\n")
	sb.WriteString("  if opts.underline then hl.underline = true end\n")
	sb.WriteString("  if opts.undercurl then hl.undercurl = true end\n")
	sb.WriteString("  vim.api.nvim_set_hl(0, group, hl)\n")
	sb.WriteString("end\n\n")

	// Lualine theme generator
	sb.WriteString("-- Generate lualine theme from palette\n")
	sb.WriteString("function M.lualine_theme()\n")
	sb.WriteString("  local p = M.palette\n")
	sb.WriteString("  return {\n")
	sb.WriteString("    normal = {\n")
	sb.WriteString("      a = { bg = p.get(\"blue\", p.get(\"fg\")), fg = p.get(\"bg\"), gui = \"bold\" },\n")
	sb.WriteString("      b = { bg = p.get(\"bg_highlight\", p.get(\"bg\")), fg = p.get(\"fg\") },\n")
	sb.WriteString("      c = { bg = p.get(\"bg_statusline\", p.get(\"bg\")), fg = p.get(\"fg_dark\", p.get(\"fg\")) },\n")
	sb.WriteString("    },\n")
	sb.WriteString("    insert = {\n")
	sb.WriteString("      a = { bg = p.get(\"green\", p.get(\"fg\")), fg = p.get(\"bg\"), gui = \"bold\" },\n")
	sb.WriteString("    },\n")
	sb.WriteString("    visual = {\n")
	sb.WriteString("      a = { bg = p.get(\"purple\", p.get(\"magenta\", p.get(\"fg\"))), fg = p.get(\"bg\"), gui = \"bold\" },\n")
	sb.WriteString("    },\n")
	sb.WriteString("    replace = {\n")
	sb.WriteString("      a = { bg = p.get(\"red\", p.get(\"fg\")), fg = p.get(\"bg\"), gui = \"bold\" },\n")
	sb.WriteString("    },\n")
	sb.WriteString("    command = {\n")
	sb.WriteString("      a = { bg = p.get(\"yellow\", p.get(\"orange\", p.get(\"fg\"))), fg = p.get(\"bg\"), gui = \"bold\" },\n")
	sb.WriteString("    },\n")
	sb.WriteString("    inactive = {\n")
	sb.WriteString("      a = { bg = p.get(\"bg_statusline\", p.get(\"bg\")), fg = p.get(\"fg_gutter\", p.get(\"fg\")) },\n")
	sb.WriteString("      b = { bg = p.get(\"bg_statusline\", p.get(\"bg\")), fg = p.get(\"fg_gutter\", p.get(\"fg\")) },\n")
	sb.WriteString("      c = { bg = p.get(\"bg_statusline\", p.get(\"bg\")), fg = p.get(\"fg_gutter\", p.get(\"fg\")) },\n")
	sb.WriteString("    },\n")
	sb.WriteString("  }\n")
	sb.WriteString("end\n\n")

	// Bufferline highlights generator
	sb.WriteString("-- Generate bufferline highlights from palette\n")
	sb.WriteString("function M.bufferline_highlights()\n")
	sb.WriteString("  local p = M.palette\n")
	sb.WriteString("  return {\n")
	sb.WriteString("    fill = { bg = p.get(\"bg_dark\", p.get(\"bg\")) },\n")
	sb.WriteString("    background = { bg = p.get(\"bg_dark\", p.get(\"bg\")), fg = p.get(\"fg_gutter\", p.get(\"fg\")) },\n")
	sb.WriteString("    buffer_selected = { bg = p.get(\"bg\"), fg = p.get(\"fg\"), bold = true },\n")
	sb.WriteString("    separator = { bg = p.get(\"bg_dark\", p.get(\"bg\")), fg = p.get(\"bg_dark\", p.get(\"bg\")) },\n")
	sb.WriteString("    separator_selected = { bg = p.get(\"bg\"), fg = p.get(\"bg_dark\", p.get(\"bg\")) },\n")
	sb.WriteString("  }\n")
	sb.WriteString("end\n\n")

	// Telescope border color
	sb.WriteString("-- Get telescope border color\n")
	sb.WriteString("function M.telescope_border()\n")
	sb.WriteString("  return M.palette.get(\"border\", M.palette.get(\"fg_gutter\"))\n")
	sb.WriteString("end\n\n")

	sb.WriteString("return M\n")

	return sb.String(), nil
}

// generatePlugin generates the lazy.nvim plugin spec for the colorscheme.
func (g *Generator) generatePlugin(t *Theme) (string, error) {
	// For standalone themes, generate a different plugin spec
	if t.IsStandalone() {
		return g.generateStandalonePlugin(t)
	}

	var sb strings.Builder

	sb.WriteString("-- Colorscheme: " + t.Name + "\n")
	if t.Description != "" {
		sb.WriteString("-- " + t.Description + "\n")
	}
	sb.WriteString("-- Generated by nvp (NvimOps)\n\n")

	sb.WriteString("return {\n")
	sb.WriteString(fmt.Sprintf("  %q,\n", t.Plugin.Repo))
	sb.WriteString("  priority = 1000,\n")
	sb.WriteString("  lazy = false,\n")

	if t.Plugin.Branch != "" {
		sb.WriteString(fmt.Sprintf("  branch = %q,\n", t.Plugin.Branch))
	}
	if t.Plugin.Tag != "" {
		sb.WriteString(fmt.Sprintf("  tag = %q,\n", t.Plugin.Tag))
	}

	sb.WriteString("  config = function()\n")
	sb.WriteString("    -- Load palette for reference\n")
	sb.WriteString("    local palette = require(\"theme.palette\")\n\n")

	// Generate setup based on theme plugin
	g.generateSetup(&sb, t)

	// Set colorscheme
	colorscheme := t.GetColorschemeCommand()
	sb.WriteString(fmt.Sprintf("    vim.cmd.colorscheme(%q)\n", colorscheme))

	sb.WriteString("  end,\n")
	sb.WriteString("}\n")

	return sb.String(), nil
}

// generateSetup generates the theme-specific setup code.
func (g *Generator) generateSetup(sb *strings.Builder, t *Theme) {
	setupName := GetSetupName(t.Plugin.Repo)
	if setupName == "" {
		g.generateGenericSetup(sb, t)
		return
	}

	switch setupName {
	case "tokyonight":
		g.generateTokyonightSetup(sb, t)
	case "catppuccin":
		g.generateCatppuccinSetup(sb, t)
	case "gruvbox":
		g.generateGruvboxSetup(sb, t)
	case "nord":
		g.generateNordSetup(sb, t)
	case "kanagawa":
		g.generateKanagawaSetup(sb, t)
	case "rose-pine":
		g.generateRosePineSetup(sb, t)
	case "nightfox":
		g.generateNightfoxSetup(sb, t)
	case "onedark":
		g.generateOnedarkSetup(sb, t)
	case "dracula":
		g.generateDraculaSetup(sb, t)
	default:
		g.generateGenericSetup(sb, t)
	}
}

// generateTokyonightSetup generates setup for tokyonight.nvim
func (g *Generator) generateTokyonightSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString("    require(\"tokyonight\").setup({\n")

	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("      style = %q,\n", t.Style))
	}
	sb.WriteString(fmt.Sprintf("      transparent = %s,\n", boolToLua(t.Transparent)))

	// Handle styles option
	if styles, ok := t.Options["styles"].(map[string]any); ok {
		sb.WriteString("      styles = {\n")
		for k, v := range styles {
			if t.Transparent && (v == "dark" || v == "transparent") {
				sb.WriteString(fmt.Sprintf("        %s = palette.is_transparent() and \"transparent\" or \"dark\",\n", k))
			} else {
				sb.WriteString(fmt.Sprintf("        %s = %q,\n", k, v))
			}
		}
		sb.WriteString("      },\n")
	}

	// Custom color overrides using palette
	if t.HasCustomColors() {
		sb.WriteString("      on_colors = function(colors)\n")
		g.writeTokyonightColorOverrides(sb, t)
		sb.WriteString("      end,\n")
	}

	sb.WriteString("    })\n\n")
}

// writeTokyonightColorOverrides writes color overrides for tokyonight
func (g *Generator) writeTokyonightColorOverrides(sb *strings.Builder, t *Theme) {
	colorMap := map[string]string{
		"bg":            "colors.bg = palette.colors.bg",
		"bg_dark":       "colors.bg_dark = palette.is_transparent() and colors.none or palette.colors.bg_dark",
		"bg_float":      "colors.bg_float = palette.is_transparent() and colors.none or palette.colors.bg_dark",
		"bg_highlight":  "colors.bg_highlight = palette.colors.bg_highlight",
		"bg_popup":      "colors.bg_popup = palette.colors.bg_dark or palette.colors.bg_popup",
		"bg_search":     "colors.bg_search = palette.colors.bg_search",
		"bg_sidebar":    "colors.bg_sidebar = palette.is_transparent() and colors.none or palette.colors.bg_dark",
		"bg_statusline": "colors.bg_statusline = palette.is_transparent() and colors.none or palette.colors.bg_dark",
		"bg_visual":     "colors.bg_visual = palette.colors.bg_visual",
		"border":        "colors.border = palette.colors.border",
		"fg":            "colors.fg = palette.colors.fg",
		"fg_dark":       "colors.fg_dark = palette.colors.fg_dark",
		"fg_float":      "colors.fg_float = palette.colors.fg",
		"fg_gutter":     "colors.fg_gutter = palette.colors.fg_gutter",
		"fg_sidebar":    "colors.fg_sidebar = palette.colors.fg_dark",
	}

	for key := range t.Colors {
		if override, ok := colorMap[key]; ok {
			sb.WriteString(fmt.Sprintf("        %s\n", override))
		}
	}
}

// generateCatppuccinSetup generates setup for catppuccin/nvim
func (g *Generator) generateCatppuccinSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString("    require(\"catppuccin\").setup({\n")

	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("      flavour = %q,\n", t.Style))
	}
	sb.WriteString(fmt.Sprintf("      transparent_background = %s,\n", boolToLua(t.Transparent)))

	if t.HasCustomColors() {
		sb.WriteString("      color_overrides = {\n")
		sb.WriteString("        all = palette.colors,\n")
		sb.WriteString("      },\n")
	}

	sb.WriteString("    })\n\n")
}

// generateGruvboxSetup generates setup for gruvbox.nvim
func (g *Generator) generateGruvboxSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString("    require(\"gruvbox\").setup({\n")
	sb.WriteString(fmt.Sprintf("      transparent_mode = %s,\n", boolToLua(t.Transparent)))

	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("      contrast = %q,\n", t.Style))
	}

	if t.HasCustomColors() {
		sb.WriteString("      palette_overrides = palette.colors,\n")
	}

	sb.WriteString("    })\n\n")
}

// generateNordSetup generates setup for nord.nvim
func (g *Generator) generateNordSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString(fmt.Sprintf("    vim.g.nord_disable_background = %s\n", boolToLua(t.Transparent)))

	if t.HasOptions() {
		for key, value := range t.Options {
			sb.WriteString(fmt.Sprintf("    vim.g.nord_%s = %s\n", key, toLuaValue(value)))
		}
	}

	sb.WriteString("    require(\"nord\").set()\n\n")
}

// generateKanagawaSetup generates setup for kanagawa.nvim
func (g *Generator) generateKanagawaSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString("    require(\"kanagawa\").setup({\n")
	sb.WriteString(fmt.Sprintf("      transparent = %s,\n", boolToLua(t.Transparent)))

	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("      theme = %q,\n", t.Style))
	}

	if t.HasCustomColors() {
		sb.WriteString("      colors = { theme = { all = palette.colors } },\n")
	}

	sb.WriteString("    })\n\n")
}

// generateRosePineSetup generates setup for rose-pine/neovim
func (g *Generator) generateRosePineSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString("    require(\"rose-pine\").setup({\n")

	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("      variant = %q,\n", t.Style))
	}
	sb.WriteString(fmt.Sprintf("      disable_background = %s,\n", boolToLua(t.Transparent)))

	if t.HasCustomColors() {
		sb.WriteString("      palette = palette.colors,\n")
	}

	sb.WriteString("    })\n\n")
}

// generateNightfoxSetup generates setup for nightfox.nvim
func (g *Generator) generateNightfoxSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString("    require(\"nightfox\").setup({\n")
	sb.WriteString("      options = {\n")
	sb.WriteString(fmt.Sprintf("        transparent = %s,\n", boolToLua(t.Transparent)))
	sb.WriteString("      },\n")

	if t.HasCustomColors() {
		sb.WriteString("      palettes = { all = palette.colors },\n")
	}

	sb.WriteString("    })\n\n")
}

// generateOnedarkSetup generates setup for onedark.nvim
func (g *Generator) generateOnedarkSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString("    require(\"onedark\").setup({\n")

	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("      style = %q,\n", t.Style))
	}
	sb.WriteString(fmt.Sprintf("      transparent = %s,\n", boolToLua(t.Transparent)))

	if t.HasCustomColors() {
		sb.WriteString("      colors = palette.colors,\n")
	}

	sb.WriteString("    })\n")
	sb.WriteString("    require(\"onedark\").load()\n\n")
}

// generateDraculaSetup generates setup for dracula.nvim
func (g *Generator) generateDraculaSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString(fmt.Sprintf("    vim.g.dracula_transparent_bg = %s\n", boolToLua(t.Transparent)))

	if t.HasCustomColors() {
		sb.WriteString("    vim.g.dracula_colors = palette.colors\n")
	}

	sb.WriteString("\n")
}

// generateGenericSetup generates a generic setup for unknown themes
func (g *Generator) generateGenericSetup(sb *strings.Builder, t *Theme) {
	parts := strings.Split(t.Plugin.Repo, "/")
	if len(parts) != 2 {
		return
	}

	moduleName := strings.TrimSuffix(parts[1], ".nvim")
	moduleName = strings.TrimSuffix(moduleName, "-nvim")
	moduleName = strings.ReplaceAll(moduleName, "-", "_")

	sb.WriteString(fmt.Sprintf("    local ok, theme = pcall(require, %q)\n", moduleName))
	sb.WriteString("    if ok and theme.setup then\n")
	sb.WriteString("      theme.setup({\n")
	sb.WriteString(fmt.Sprintf("        transparent = %s,\n", boolToLua(t.Transparent)))
	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("        style = %q,\n", t.Style))
	}
	if t.HasCustomColors() {
		sb.WriteString("        colors = palette.colors,\n")
	}
	sb.WriteString("      })\n")
	sb.WriteString("    end\n\n")
}

// boolToLua converts a bool to Lua boolean string
func boolToLua(b bool) string {
	if b {
		return "true"
	}
	return "false"
}

// toLuaValue converts a Go value to Lua representation
func toLuaValue(v any) string {
	switch val := v.(type) {
	case bool:
		return boolToLua(val)
	case string:
		return fmt.Sprintf("%q", val)
	case int, int64, float64:
		return fmt.Sprintf("%v", val)
	case map[string]any:
		var sb strings.Builder
		sb.WriteString("{\n")
		for k, v := range val {
			sb.WriteString(fmt.Sprintf("        %s = %s,\n", k, toLuaValue(v)))
		}
		sb.WriteString("      }")
		return sb.String()
	default:
		return fmt.Sprintf("%v", val)
	}
}

// =============================================================================
// Standalone Theme Generation
// =============================================================================

// generateStandalonePlugin generates a lazy.nvim plugin spec for standalone themes.
// This creates a plugin that loads from the local theme directory instead of a repo.
func (g *Generator) generateStandalonePlugin(t *Theme) (string, error) {
	var sb strings.Builder

	sb.WriteString("-- Standalone Colorscheme: " + t.Name + "\n")
	if t.Description != "" {
		sb.WriteString("-- " + t.Description + "\n")
	}
	sb.WriteString("-- Self-contained theme - no external plugin required\n")
	sb.WriteString("-- Generated by nvp (NvimOps)\n\n")

	sb.WriteString("return {\n")
	sb.WriteString("  dir = vim.fn.stdpath(\"config\") .. \"/lua/theme\",\n")
	sb.WriteString(fmt.Sprintf("  name = %q,\n", t.Name))
	sb.WriteString("  priority = 1000,\n")
	sb.WriteString("  lazy = false,\n")
	sb.WriteString("  config = function()\n")
	sb.WriteString("    require(\"theme.colorscheme\").setup()\n")
	sb.WriteString("  end,\n")
	sb.WriteString("}\n")

	return sb.String(), nil
}

// generateStandaloneColorscheme generates a self-contained colorscheme implementation.
// This creates a colorscheme that applies highlights directly via vim.api.nvim_set_hl().
func (g *Generator) generateStandaloneColorscheme(t *Theme) (string, error) {
	var sb strings.Builder

	sb.WriteString("-- Colorscheme: " + t.Name + "\n")
	if t.Description != "" {
		sb.WriteString("-- " + t.Description + "\n")
	}
	sb.WriteString("-- Self-contained parametric theme\n")
	sb.WriteString("-- Generated by nvp (NvimOps)\n\n")

	sb.WriteString("local M = {}\n\n")

	sb.WriteString("function M.setup(opts)\n")
	sb.WriteString("  opts = opts or {}\n")
	sb.WriteString("  local palette = require(\"theme.palette\")\n")
	sb.WriteString("  local colors = palette.colors\n\n")

	sb.WriteString("  -- Clear existing highlights\n")
	sb.WriteString("  vim.cmd(\"hi clear\")\n")
	sb.WriteString("  if vim.fn.exists(\"syntax_on\") then\n")
	sb.WriteString("    vim.cmd(\"syntax reset\")\n")
	sb.WriteString("  end\n\n")

	sb.WriteString("  -- Set colorscheme name\n")
	sb.WriteString(fmt.Sprintf("  vim.g.colors_name = %q\n\n", t.Name))

	sb.WriteString("  -- Helper function to apply highlights\n")
	sb.WriteString("  local hl = function(name, val)\n")
	sb.WriteString("    vim.api.nvim_set_hl(0, name, val)\n")
	sb.WriteString("  end\n\n")

	// Generate highlight groups
	g.generateStandaloneHighlights(&sb, t)

	sb.WriteString("end\n\n")

	sb.WriteString("-- Auto-setup on load\n")
	sb.WriteString("M.setup()\n\n")

	sb.WriteString("return M\n")

	return sb.String(), nil
}

// generateStandaloneHighlights generates all highlight groups for a standalone theme.
func (g *Generator) generateStandaloneHighlights(sb *strings.Builder, t *Theme) {
	// UI highlight groups
	sb.WriteString("  -- UI Groups\n")
	g.writeHighlight(sb, "Normal", map[string]string{"fg": "fg", "bg": "bg"}, t.Transparent)
	g.writeHighlight(sb, "NormalFloat", map[string]string{"fg": "fg", "bg": "bg_dark"}, t.Transparent)
	g.writeHighlight(sb, "NormalNC", map[string]string{"fg": "fg_dark", "bg": "bg"}, t.Transparent)
	g.writeHighlight(sb, "CursorLine", map[string]string{"bg": "bg_highlight"}, false)
	g.writeHighlight(sb, "CursorColumn", map[string]string{"bg": "bg_highlight"}, false)
	g.writeHighlight(sb, "Visual", map[string]string{"bg": "bg_visual"}, false)
	g.writeHighlight(sb, "Search", map[string]string{"fg": "bg", "bg": "bg_search"}, false)
	g.writeHighlight(sb, "IncSearch", map[string]string{"fg": "bg", "bg": "orange"}, false)

	// Status line
	g.writeHighlight(sb, "StatusLine", map[string]string{"fg": "fg", "bg": "bg_statusline"}, t.Transparent)
	g.writeHighlight(sb, "StatusLineNC", map[string]string{"fg": "fg_gutter", "bg": "bg_statusline"}, t.Transparent)

	// Tab line
	g.writeHighlight(sb, "TabLine", map[string]string{"fg": "fg_gutter", "bg": "bg_statusline"}, t.Transparent)
	g.writeHighlight(sb, "TabLineFill", map[string]string{"bg": "bg_dark"}, t.Transparent)
	g.writeHighlight(sb, "TabLineSel", map[string]string{"fg": "fg", "bg": "bg"}, false)

	// Popup menu
	g.writeHighlight(sb, "Pmenu", map[string]string{"fg": "fg", "bg": "bg_popup"}, t.Transparent)
	g.writeHighlight(sb, "PmenuSel", map[string]string{"fg": "bg", "bg": "blue"}, false)
	g.writeHighlight(sb, "PmenuSbar", map[string]string{"bg": "bg_highlight"}, t.Transparent)
	g.writeHighlight(sb, "PmenuThumb", map[string]string{"bg": "fg_gutter"}, false)

	// Line numbers and signs
	g.writeHighlight(sb, "LineNr", map[string]string{"fg": "fg_gutter"}, false)
	g.writeHighlight(sb, "CursorLineNr", map[string]string{"fg": "orange", "bold": "true"}, false)
	g.writeHighlight(sb, "SignColumn", map[string]string{"fg": "fg_gutter", "bg": "bg"}, t.Transparent)
	g.writeHighlight(sb, "VertSplit", map[string]string{"fg": "border"}, false)
	g.writeHighlight(sb, "WinSeparator", map[string]string{"fg": "border"}, false)

	sb.WriteString("\n  -- Syntax Groups\n")

	// Comments
	g.writeHighlight(sb, "Comment", map[string]string{"fg": "comment", "italic": "true"}, false)
	g.writeHighlight(sb, "NonText", map[string]string{"fg": "fg_gutter"}, false)
	g.writeHighlight(sb, "SpecialKey", map[string]string{"fg": "fg_gutter"}, false)

	// Constants and literals
	g.writeHighlight(sb, "String", map[string]string{"fg": "green"}, false)
	g.writeHighlight(sb, "Number", map[string]string{"fg": "orange"}, false)
	g.writeHighlight(sb, "Boolean", map[string]string{"fg": "orange"}, false)
	g.writeHighlight(sb, "Float", map[string]string{"fg": "orange"}, false)
	g.writeHighlight(sb, "Character", map[string]string{"fg": "green"}, false)
	g.writeHighlight(sb, "Constant", map[string]string{"fg": "orange"}, false)

	// Identifiers and functions
	g.writeHighlight(sb, "Identifier", map[string]string{"fg": "red"}, false)
	g.writeHighlight(sb, "Function", map[string]string{"fg": "blue", "bold": "true"}, false)

	// Statements and keywords
	g.writeHighlight(sb, "Statement", map[string]string{"fg": "purple", "bold": "true"}, false)
	g.writeHighlight(sb, "Keyword", map[string]string{"fg": "purple", "bold": "true"}, false)
	g.writeHighlight(sb, "Conditional", map[string]string{"fg": "purple", "bold": "true"}, false)
	g.writeHighlight(sb, "Repeat", map[string]string{"fg": "purple", "bold": "true"}, false)
	g.writeHighlight(sb, "Label", map[string]string{"fg": "purple"}, false)
	g.writeHighlight(sb, "Operator", map[string]string{"fg": "fg"}, false)
	g.writeHighlight(sb, "Exception", map[string]string{"fg": "red", "bold": "true"}, false)

	// Types and structures
	g.writeHighlight(sb, "Type", map[string]string{"fg": "cyan", "bold": "true"}, false)
	g.writeHighlight(sb, "Structure", map[string]string{"fg": "cyan"}, false)
	g.writeHighlight(sb, "StorageClass", map[string]string{"fg": "purple"}, false)
	g.writeHighlight(sb, "Typedef", map[string]string{"fg": "cyan"}, false)

	// Preprocessor
	g.writeHighlight(sb, "PreProc", map[string]string{"fg": "magenta"}, false)
	g.writeHighlight(sb, "Include", map[string]string{"fg": "magenta"}, false)
	g.writeHighlight(sb, "Define", map[string]string{"fg": "magenta"}, false)
	g.writeHighlight(sb, "Macro", map[string]string{"fg": "magenta"}, false)
	g.writeHighlight(sb, "PreCondit", map[string]string{"fg": "magenta"}, false)

	// Special
	g.writeHighlight(sb, "Special", map[string]string{"fg": "cyan"}, false)
	g.writeHighlight(sb, "SpecialChar", map[string]string{"fg": "cyan"}, false)
	g.writeHighlight(sb, "Tag", map[string]string{"fg": "red"}, false)
	g.writeHighlight(sb, "Delimiter", map[string]string{"fg": "fg"}, false)
	g.writeHighlight(sb, "Debug", map[string]string{"fg": "red"}, false)

	sb.WriteString("\n  -- Diagnostics\n")
	g.writeHighlight(sb, "DiagnosticError", map[string]string{"fg": "error"}, false)
	g.writeHighlight(sb, "DiagnosticWarn", map[string]string{"fg": "warning"}, false)
	g.writeHighlight(sb, "DiagnosticInfo", map[string]string{"fg": "info"}, false)
	g.writeHighlight(sb, "DiagnosticHint", map[string]string{"fg": "hint"}, false)

	// Underlines for diagnostics
	g.writeHighlight(sb, "DiagnosticUnderlineError", map[string]string{"sp": "error", "undercurl": "true"}, false)
	g.writeHighlight(sb, "DiagnosticUnderlineWarn", map[string]string{"sp": "warning", "undercurl": "true"}, false)
	g.writeHighlight(sb, "DiagnosticUnderlineInfo", map[string]string{"sp": "info", "undercurl": "true"}, false)
	g.writeHighlight(sb, "DiagnosticUnderlineHint", map[string]string{"sp": "hint", "undercurl": "true"}, false)

	sb.WriteString("\n  -- Git Signs (if using gitsigns.nvim)\n")
	g.writeHighlight(sb, "GitSignsAdd", map[string]string{"fg": "green"}, false)
	g.writeHighlight(sb, "GitSignsChange", map[string]string{"fg": "yellow"}, false)
	g.writeHighlight(sb, "GitSignsDelete", map[string]string{"fg": "red"}, false)

	sb.WriteString("\n  -- Treesitter highlights\n")
	g.writeHighlight(sb, "@comment", map[string]string{"link": "Comment"}, false)
	g.writeHighlight(sb, "@string", map[string]string{"link": "String"}, false)
	g.writeHighlight(sb, "@number", map[string]string{"link": "Number"}, false)
	g.writeHighlight(sb, "@boolean", map[string]string{"link": "Boolean"}, false)
	g.writeHighlight(sb, "@function", map[string]string{"link": "Function"}, false)
	g.writeHighlight(sb, "@keyword", map[string]string{"link": "Keyword"}, false)
	g.writeHighlight(sb, "@type", map[string]string{"link": "Type"}, false)
	g.writeHighlight(sb, "@variable", map[string]string{"link": "Identifier"}, false)
}

// writeHighlight writes a single highlight group definition.
func (g *Generator) writeHighlight(sb *strings.Builder, group string, attrs map[string]string, transparent bool) {
	sb.WriteString(fmt.Sprintf("  hl(%q, {", group))

	first := true
	for attr, colorKey := range attrs {
		if !first {
			sb.WriteString(", ")
		}
		first = false

		switch attr {
		case "bold", "italic", "underline", "undercurl":
			sb.WriteString(fmt.Sprintf(" %s = %s", attr, colorKey))
		case "link":
			sb.WriteString(fmt.Sprintf(" link = %q", colorKey))
		default:
			// Handle transparent backgrounds
			if transparent && attr == "bg" && (colorKey == "bg_statusline" || colorKey == "bg_sidebar" || colorKey == "bg_float" || colorKey == "bg_popup" || colorKey == "bg_dark") {
				sb.WriteString(fmt.Sprintf(" %s = palette.is_transparent() and \"NONE\" or colors.%s", attr, colorKey))
			} else {
				sb.WriteString(fmt.Sprintf(" %s = colors.%s", attr, colorKey))
			}
		}
	}

	sb.WriteString(" })\n")
}
