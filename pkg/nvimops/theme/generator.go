package theme

import (
	"fmt"
	"sort"
	"strings"
)

// Generator generates Lua code for themes.
type Generator struct{}

// NewGenerator creates a new theme Lua generator.
func NewGenerator() *Generator {
	return &Generator{}
}

// GeneratedTheme contains all generated Lua files for a theme.
type GeneratedTheme struct {
	// PaletteLua is the palette module (theme/palette.lua)
	PaletteLua string
	// InitLua is the theme setup (theme/init.lua)
	InitLua string
	// PluginLua is the lazy.nvim plugin spec (plugins/colorscheme.lua)
	PluginLua string
}

// Generate generates all Lua files for a theme.
func (g *Generator) Generate(t *Theme) (*GeneratedTheme, error) {
	if err := t.Validate(); err != nil {
		return nil, err
	}

	palette, err := g.generatePalette(t)
	if err != nil {
		return nil, err
	}

	initLua, err := g.generateInit(t)
	if err != nil {
		return nil, err
	}

	pluginLua, err := g.generatePlugin(t)
	if err != nil {
		return nil, err
	}

	return &GeneratedTheme{
		PaletteLua: palette,
		InitLua:    initLua,
		PluginLua:  pluginLua,
	}, nil
}

// generatePalette generates the palette module that other plugins can require.
// Usage in other plugins: local palette = require("theme").palette
func (g *Generator) generatePalette(t *Theme) (string, error) {
	var sb strings.Builder

	sb.WriteString("-- Theme Palette: " + t.Name + "\n")
	sb.WriteString("-- This module exports theme colors for use by other plugins.\n")
	sb.WriteString("-- Usage: local palette = require(\"theme\").palette\n")
	sb.WriteString("-- Generated by nvp (NvimOps)\n\n")

	sb.WriteString("local M = {}\n\n")

	// Theme metadata
	sb.WriteString("-- Theme metadata\n")
	sb.WriteString(fmt.Sprintf("M.name = %q\n", t.Name))
	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("M.style = %q\n", t.Style))
	}
	sb.WriteString(fmt.Sprintf("M.transparent = %s\n", boolToLua(t.Transparent)))
	sb.WriteString("\n")

	// Colors palette
	sb.WriteString("-- Color palette\n")
	sb.WriteString("M.colors = {\n")

	// Sort keys for consistent output
	keys := make([]string, 0, len(t.Colors))
	for k := range t.Colors {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, key := range keys {
		sb.WriteString(fmt.Sprintf("  %s = %q,\n", key, t.Colors[key]))
	}
	sb.WriteString("}\n\n")

	// Semantic color aliases (common names that plugins expect)
	sb.WriteString("-- Semantic aliases for common plugin usage\n")
	sb.WriteString("M.semantic = {\n")
	g.writeSemanticAliases(&sb, t)
	sb.WriteString("}\n\n")

	// Helper function to get color with fallback
	sb.WriteString("-- Get a color with optional fallback\n")
	sb.WriteString("function M.get(name, fallback)\n")
	sb.WriteString("  return M.colors[name] or M.semantic[name] or fallback\n")
	sb.WriteString("end\n\n")

	// Helper to check if transparent mode
	sb.WriteString("-- Check if transparent mode is enabled\n")
	sb.WriteString("function M.is_transparent()\n")
	sb.WriteString("  return M.transparent\n")
	sb.WriteString("end\n\n")

	sb.WriteString("return M\n")

	return sb.String(), nil
}

// writeSemanticAliases maps theme colors to common semantic names
func (g *Generator) writeSemanticAliases(sb *strings.Builder, t *Theme) {
	// Map common color names to semantic meanings
	semanticMap := map[string][]string{
		"background":  {"bg", "bg_dark"},
		"foreground":  {"fg", "fg_dark"},
		"selection":   {"bg_visual", "bg_highlight"},
		"comment":     {"comment", "fg_gutter"},
		"border":      {"border", "fg_gutter"},
		"cursor_line": {"bg_highlight", "bg_visual"},
		"search":      {"bg_search", "bg_highlight"},
		"popup":       {"bg_popup", "bg_float", "bg_dark"},
		"sidebar":     {"bg_sidebar", "bg_dark"},
		"statusline":  {"bg_statusline", "bg_dark"},
		"error":       {"error", "red"},
		"warning":     {"warning", "yellow", "orange"},
		"info":        {"info", "blue", "cyan"},
		"hint":        {"hint", "cyan", "teal"},
		"success":     {"success", "green"},
		"added":       {"added", "git_add", "green"},
		"modified":    {"modified", "git_change", "blue", "yellow"},
		"removed":     {"removed", "git_delete", "red"},
	}

	for semantic, candidates := range semanticMap {
		for _, candidate := range candidates {
			if color, ok := t.Colors[candidate]; ok {
				sb.WriteString(fmt.Sprintf("  %s = %q,\n", semantic, color))
				break
			}
		}
	}
}

// generateInit generates the theme init module.
func (g *Generator) generateInit(t *Theme) (string, error) {
	var sb strings.Builder

	sb.WriteString("-- Theme: " + t.Name + "\n")
	if t.Description != "" {
		sb.WriteString("-- " + t.Description + "\n")
	}
	sb.WriteString("-- Generated by nvp (NvimOps)\n\n")

	sb.WriteString("local M = {}\n\n")

	// Re-export palette
	sb.WriteString("-- Re-export palette for easy access\n")
	sb.WriteString("M.palette = require(\"theme.palette\")\n\n")

	// Setup function that plugins can call
	sb.WriteString("-- Setup function (called automatically by colorscheme plugin)\n")
	sb.WriteString("function M.setup()\n")
	sb.WriteString("  -- Theme is configured via the colorscheme plugin\n")
	sb.WriteString("  -- This function is for any additional setup if needed\n")
	sb.WriteString("end\n\n")

	// Helper to apply highlights using palette
	sb.WriteString("-- Apply a highlight group using palette colors\n")
	sb.WriteString("function M.highlight(group, opts)\n")
	sb.WriteString("  local hl = {}\n")
	sb.WriteString("  if opts.fg then hl.fg = M.palette.get(opts.fg, opts.fg) end\n")
	sb.WriteString("  if opts.bg then hl.bg = M.palette.get(opts.bg, opts.bg) end\n")
	sb.WriteString("  if opts.sp then hl.sp = M.palette.get(opts.sp, opts.sp) end\n")
	sb.WriteString("  if opts.bold then hl.bold = true end\n")
	sb.WriteString("  if opts.italic then hl.italic = true end\n")
	sb.WriteString("  if opts.underline then hl.underline = true end\n")
	sb.WriteString("  if opts.undercurl then hl.undercurl = true end\n")
	sb.WriteString("  vim.api.nvim_set_hl(0, group, hl)\n")
	sb.WriteString("end\n\n")

	// Lualine theme generator
	sb.WriteString("-- Generate lualine theme from palette\n")
	sb.WriteString("function M.lualine_theme()\n")
	sb.WriteString("  local p = M.palette\n")
	sb.WriteString("  return {\n")
	sb.WriteString("    normal = {\n")
	sb.WriteString("      a = { bg = p.get(\"blue\", p.get(\"fg\")), fg = p.get(\"bg\"), gui = \"bold\" },\n")
	sb.WriteString("      b = { bg = p.get(\"bg_highlight\", p.get(\"bg\")), fg = p.get(\"fg\") },\n")
	sb.WriteString("      c = { bg = p.get(\"bg_statusline\", p.get(\"bg\")), fg = p.get(\"fg_dark\", p.get(\"fg\")) },\n")
	sb.WriteString("    },\n")
	sb.WriteString("    insert = {\n")
	sb.WriteString("      a = { bg = p.get(\"green\", p.get(\"fg\")), fg = p.get(\"bg\"), gui = \"bold\" },\n")
	sb.WriteString("    },\n")
	sb.WriteString("    visual = {\n")
	sb.WriteString("      a = { bg = p.get(\"purple\", p.get(\"magenta\", p.get(\"fg\"))), fg = p.get(\"bg\"), gui = \"bold\" },\n")
	sb.WriteString("    },\n")
	sb.WriteString("    replace = {\n")
	sb.WriteString("      a = { bg = p.get(\"red\", p.get(\"fg\")), fg = p.get(\"bg\"), gui = \"bold\" },\n")
	sb.WriteString("    },\n")
	sb.WriteString("    command = {\n")
	sb.WriteString("      a = { bg = p.get(\"yellow\", p.get(\"orange\", p.get(\"fg\"))), fg = p.get(\"bg\"), gui = \"bold\" },\n")
	sb.WriteString("    },\n")
	sb.WriteString("    inactive = {\n")
	sb.WriteString("      a = { bg = p.get(\"bg_statusline\", p.get(\"bg\")), fg = p.get(\"fg_gutter\", p.get(\"fg\")) },\n")
	sb.WriteString("      b = { bg = p.get(\"bg_statusline\", p.get(\"bg\")), fg = p.get(\"fg_gutter\", p.get(\"fg\")) },\n")
	sb.WriteString("      c = { bg = p.get(\"bg_statusline\", p.get(\"bg\")), fg = p.get(\"fg_gutter\", p.get(\"fg\")) },\n")
	sb.WriteString("    },\n")
	sb.WriteString("  }\n")
	sb.WriteString("end\n\n")

	// Bufferline highlights generator
	sb.WriteString("-- Generate bufferline highlights from palette\n")
	sb.WriteString("function M.bufferline_highlights()\n")
	sb.WriteString("  local p = M.palette\n")
	sb.WriteString("  return {\n")
	sb.WriteString("    fill = { bg = p.get(\"bg_dark\", p.get(\"bg\")) },\n")
	sb.WriteString("    background = { bg = p.get(\"bg_dark\", p.get(\"bg\")), fg = p.get(\"fg_gutter\", p.get(\"fg\")) },\n")
	sb.WriteString("    buffer_selected = { bg = p.get(\"bg\"), fg = p.get(\"fg\"), bold = true },\n")
	sb.WriteString("    separator = { bg = p.get(\"bg_dark\", p.get(\"bg\")), fg = p.get(\"bg_dark\", p.get(\"bg\")) },\n")
	sb.WriteString("    separator_selected = { bg = p.get(\"bg\"), fg = p.get(\"bg_dark\", p.get(\"bg\")) },\n")
	sb.WriteString("  }\n")
	sb.WriteString("end\n\n")

	// Telescope border color
	sb.WriteString("-- Get telescope border color\n")
	sb.WriteString("function M.telescope_border()\n")
	sb.WriteString("  return M.palette.get(\"border\", M.palette.get(\"fg_gutter\"))\n")
	sb.WriteString("end\n\n")

	sb.WriteString("return M\n")

	return sb.String(), nil
}

// generatePlugin generates the lazy.nvim plugin spec for the colorscheme.
func (g *Generator) generatePlugin(t *Theme) (string, error) {
	var sb strings.Builder

	sb.WriteString("-- Colorscheme: " + t.Name + "\n")
	if t.Description != "" {
		sb.WriteString("-- " + t.Description + "\n")
	}
	sb.WriteString("-- Generated by nvp (NvimOps)\n\n")

	sb.WriteString("return {\n")
	sb.WriteString(fmt.Sprintf("  %q,\n", t.Plugin.Repo))
	sb.WriteString("  priority = 1000,\n")
	sb.WriteString("  lazy = false,\n")

	if t.Plugin.Branch != "" {
		sb.WriteString(fmt.Sprintf("  branch = %q,\n", t.Plugin.Branch))
	}
	if t.Plugin.Tag != "" {
		sb.WriteString(fmt.Sprintf("  tag = %q,\n", t.Plugin.Tag))
	}

	sb.WriteString("  config = function()\n")
	sb.WriteString("    -- Load palette for reference\n")
	sb.WriteString("    local palette = require(\"theme.palette\")\n\n")

	// Generate setup based on theme plugin
	g.generateSetup(&sb, t)

	// Set colorscheme
	colorscheme := t.GetColorschemeCommand()
	sb.WriteString(fmt.Sprintf("    vim.cmd.colorscheme(%q)\n", colorscheme))

	sb.WriteString("  end,\n")
	sb.WriteString("}\n")

	return sb.String(), nil
}

// generateSetup generates the theme-specific setup code.
func (g *Generator) generateSetup(sb *strings.Builder, t *Theme) {
	setupName := GetSetupName(t.Plugin.Repo)
	if setupName == "" {
		g.generateGenericSetup(sb, t)
		return
	}

	switch setupName {
	case "tokyonight":
		g.generateTokyonightSetup(sb, t)
	case "catppuccin":
		g.generateCatppuccinSetup(sb, t)
	case "gruvbox":
		g.generateGruvboxSetup(sb, t)
	case "nord":
		g.generateNordSetup(sb, t)
	case "kanagawa":
		g.generateKanagawaSetup(sb, t)
	case "rose-pine":
		g.generateRosePineSetup(sb, t)
	case "nightfox":
		g.generateNightfoxSetup(sb, t)
	case "onedark":
		g.generateOnedarkSetup(sb, t)
	case "dracula":
		g.generateDraculaSetup(sb, t)
	default:
		g.generateGenericSetup(sb, t)
	}
}

// generateTokyonightSetup generates setup for tokyonight.nvim
func (g *Generator) generateTokyonightSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString("    require(\"tokyonight\").setup({\n")

	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("      style = %q,\n", t.Style))
	}
	sb.WriteString(fmt.Sprintf("      transparent = %s,\n", boolToLua(t.Transparent)))

	// Handle styles option
	if styles, ok := t.Options["styles"].(map[string]any); ok {
		sb.WriteString("      styles = {\n")
		for k, v := range styles {
			if t.Transparent && (v == "dark" || v == "transparent") {
				sb.WriteString(fmt.Sprintf("        %s = palette.is_transparent() and \"transparent\" or \"dark\",\n", k))
			} else {
				sb.WriteString(fmt.Sprintf("        %s = %q,\n", k, v))
			}
		}
		sb.WriteString("      },\n")
	}

	// Custom color overrides using palette
	if t.HasCustomColors() {
		sb.WriteString("      on_colors = function(colors)\n")
		g.writeTokyonightColorOverrides(sb, t)
		sb.WriteString("      end,\n")
	}

	sb.WriteString("    })\n\n")
}

// writeTokyonightColorOverrides writes color overrides for tokyonight
func (g *Generator) writeTokyonightColorOverrides(sb *strings.Builder, t *Theme) {
	colorMap := map[string]string{
		"bg":            "colors.bg = palette.colors.bg",
		"bg_dark":       "colors.bg_dark = palette.is_transparent() and colors.none or palette.colors.bg_dark",
		"bg_float":      "colors.bg_float = palette.is_transparent() and colors.none or palette.colors.bg_dark",
		"bg_highlight":  "colors.bg_highlight = palette.colors.bg_highlight",
		"bg_popup":      "colors.bg_popup = palette.colors.bg_dark or palette.colors.bg_popup",
		"bg_search":     "colors.bg_search = palette.colors.bg_search",
		"bg_sidebar":    "colors.bg_sidebar = palette.is_transparent() and colors.none or palette.colors.bg_dark",
		"bg_statusline": "colors.bg_statusline = palette.is_transparent() and colors.none or palette.colors.bg_dark",
		"bg_visual":     "colors.bg_visual = palette.colors.bg_visual",
		"border":        "colors.border = palette.colors.border",
		"fg":            "colors.fg = palette.colors.fg",
		"fg_dark":       "colors.fg_dark = palette.colors.fg_dark",
		"fg_float":      "colors.fg_float = palette.colors.fg",
		"fg_gutter":     "colors.fg_gutter = palette.colors.fg_gutter",
		"fg_sidebar":    "colors.fg_sidebar = palette.colors.fg_dark",
	}

	for key := range t.Colors {
		if override, ok := colorMap[key]; ok {
			sb.WriteString(fmt.Sprintf("        %s\n", override))
		}
	}
}

// generateCatppuccinSetup generates setup for catppuccin/nvim
func (g *Generator) generateCatppuccinSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString("    require(\"catppuccin\").setup({\n")

	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("      flavour = %q,\n", t.Style))
	}
	sb.WriteString(fmt.Sprintf("      transparent_background = %s,\n", boolToLua(t.Transparent)))

	if t.HasCustomColors() {
		sb.WriteString("      color_overrides = {\n")
		sb.WriteString("        all = palette.colors,\n")
		sb.WriteString("      },\n")
	}

	sb.WriteString("    })\n\n")
}

// generateGruvboxSetup generates setup for gruvbox.nvim
func (g *Generator) generateGruvboxSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString("    require(\"gruvbox\").setup({\n")
	sb.WriteString(fmt.Sprintf("      transparent_mode = %s,\n", boolToLua(t.Transparent)))

	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("      contrast = %q,\n", t.Style))
	}

	if t.HasCustomColors() {
		sb.WriteString("      palette_overrides = palette.colors,\n")
	}

	sb.WriteString("    })\n\n")
}

// generateNordSetup generates setup for nord.nvim
func (g *Generator) generateNordSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString(fmt.Sprintf("    vim.g.nord_disable_background = %s\n", boolToLua(t.Transparent)))

	if t.HasOptions() {
		for key, value := range t.Options {
			sb.WriteString(fmt.Sprintf("    vim.g.nord_%s = %s\n", key, toLuaValue(value)))
		}
	}

	sb.WriteString("    require(\"nord\").set()\n\n")
}

// generateKanagawaSetup generates setup for kanagawa.nvim
func (g *Generator) generateKanagawaSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString("    require(\"kanagawa\").setup({\n")
	sb.WriteString(fmt.Sprintf("      transparent = %s,\n", boolToLua(t.Transparent)))

	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("      theme = %q,\n", t.Style))
	}

	if t.HasCustomColors() {
		sb.WriteString("      colors = { theme = { all = palette.colors } },\n")
	}

	sb.WriteString("    })\n\n")
}

// generateRosePineSetup generates setup for rose-pine/neovim
func (g *Generator) generateRosePineSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString("    require(\"rose-pine\").setup({\n")

	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("      variant = %q,\n", t.Style))
	}
	sb.WriteString(fmt.Sprintf("      disable_background = %s,\n", boolToLua(t.Transparent)))

	if t.HasCustomColors() {
		sb.WriteString("      palette = palette.colors,\n")
	}

	sb.WriteString("    })\n\n")
}

// generateNightfoxSetup generates setup for nightfox.nvim
func (g *Generator) generateNightfoxSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString("    require(\"nightfox\").setup({\n")
	sb.WriteString("      options = {\n")
	sb.WriteString(fmt.Sprintf("        transparent = %s,\n", boolToLua(t.Transparent)))
	sb.WriteString("      },\n")

	if t.HasCustomColors() {
		sb.WriteString("      palettes = { all = palette.colors },\n")
	}

	sb.WriteString("    })\n\n")
}

// generateOnedarkSetup generates setup for onedark.nvim
func (g *Generator) generateOnedarkSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString("    require(\"onedark\").setup({\n")

	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("      style = %q,\n", t.Style))
	}
	sb.WriteString(fmt.Sprintf("      transparent = %s,\n", boolToLua(t.Transparent)))

	if t.HasCustomColors() {
		sb.WriteString("      colors = palette.colors,\n")
	}

	sb.WriteString("    })\n")
	sb.WriteString("    require(\"onedark\").load()\n\n")
}

// generateDraculaSetup generates setup for dracula.nvim
func (g *Generator) generateDraculaSetup(sb *strings.Builder, t *Theme) {
	sb.WriteString(fmt.Sprintf("    vim.g.dracula_transparent_bg = %s\n", boolToLua(t.Transparent)))

	if t.HasCustomColors() {
		sb.WriteString("    vim.g.dracula_colors = palette.colors\n")
	}

	sb.WriteString("\n")
}

// generateGenericSetup generates a generic setup for unknown themes
func (g *Generator) generateGenericSetup(sb *strings.Builder, t *Theme) {
	parts := strings.Split(t.Plugin.Repo, "/")
	if len(parts) != 2 {
		return
	}

	moduleName := strings.TrimSuffix(parts[1], ".nvim")
	moduleName = strings.TrimSuffix(moduleName, "-nvim")
	moduleName = strings.ReplaceAll(moduleName, "-", "_")

	sb.WriteString(fmt.Sprintf("    local ok, theme = pcall(require, %q)\n", moduleName))
	sb.WriteString("    if ok and theme.setup then\n")
	sb.WriteString("      theme.setup({\n")
	sb.WriteString(fmt.Sprintf("        transparent = %s,\n", boolToLua(t.Transparent)))
	if t.Style != "" {
		sb.WriteString(fmt.Sprintf("        style = %q,\n", t.Style))
	}
	if t.HasCustomColors() {
		sb.WriteString("        colors = palette.colors,\n")
	}
	sb.WriteString("      })\n")
	sb.WriteString("    end\n\n")
}

// boolToLua converts a bool to Lua boolean string
func boolToLua(b bool) string {
	if b {
		return "true"
	}
	return "false"
}

// toLuaValue converts a Go value to Lua representation
func toLuaValue(v any) string {
	switch val := v.(type) {
	case bool:
		return boolToLua(val)
	case string:
		return fmt.Sprintf("%q", val)
	case int, int64, float64:
		return fmt.Sprintf("%v", val)
	case map[string]any:
		var sb strings.Builder
		sb.WriteString("{\n")
		for k, v := range val {
			sb.WriteString(fmt.Sprintf("        %s = %s,\n", k, toLuaValue(v)))
		}
		sb.WriteString("      }")
		return sb.String()
	default:
		return fmt.Sprintf("%v", val)
	}
}
