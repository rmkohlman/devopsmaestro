package plugin

import (
	"encoding/json"
	"fmt"
	"strings"
)

// Generator converts Plugin definitions to Lua code for lazy.nvim.
type Generator struct {
	// IndentSize is the number of spaces per indentation level (default: 2)
	IndentSize int
}

// NewGenerator creates a new Lua generator with default settings.
func NewGenerator() *Generator {
	return &Generator{
		IndentSize: 2,
	}
}

// GenerateLua converts a Plugin to lazy.nvim compatible Lua code.
func (g *Generator) GenerateLua(p *Plugin) (string, error) {
	var lua strings.Builder
	indent := strings.Repeat(" ", g.IndentSize)

	// Start the plugin spec
	lua.WriteString("return {\n")
	lua.WriteString(fmt.Sprintf("%s\"%s\",\n", indent, p.Repo))

	// Branch
	if p.Branch != "" {
		lua.WriteString(fmt.Sprintf("%sbranch = \"%s\",\n", indent, p.Branch))
	}

	// Version (tag)
	if p.Version != "" {
		lua.WriteString(fmt.Sprintf("%sversion = \"%s\",\n", indent, p.Version))
	}

	// Priority
	if p.Priority != 0 {
		lua.WriteString(fmt.Sprintf("%spriority = %d,\n", indent, p.Priority))
	}

	// Event (lazy loading trigger)
	if len(p.Event) > 0 {
		g.writeStringOrArray(&lua, indent, "event", p.Event)
	}

	// Filetype
	if len(p.Ft) > 0 {
		g.writeStringOrArray(&lua, indent, "ft", p.Ft)
	}

	// Command
	if len(p.Cmd) > 0 {
		g.writeStringOrArray(&lua, indent, "cmd", p.Cmd)
	}

	// Dependencies
	if len(p.Dependencies) > 0 {
		g.writeDependencies(&lua, indent, p.Dependencies)
	}

	// Keys (lazy loading triggers)
	if len(p.Keys) > 0 {
		g.writeKeys(&lua, indent, p.Keys)
	}

	// Build command
	if p.Build != "" {
		lua.WriteString(fmt.Sprintf("%sbuild = \"%s\",\n", indent, escapeString(p.Build)))
	}

	// Init function (runs before plugin loads)
	if p.Init != "" {
		g.writeFunction(&lua, indent, "init", p.Init)
	}

	// Config function (runs after plugin loads)
	if p.Config != "" {
		g.writeFunction(&lua, indent, "config", p.Config)
	}

	// Opts (passed to plugin.setup())
	if len(p.Opts) > 0 {
		g.writeOpts(&lua, indent, p.Opts)
	}

	lua.WriteString("}\n")

	return lua.String(), nil
}

// GenerateLuaFile generates Lua and includes a header comment.
func (g *Generator) GenerateLuaFile(p *Plugin) (string, error) {
	luaCode, err := g.GenerateLua(p)
	if err != nil {
		return "", err
	}

	var result strings.Builder
	result.WriteString(fmt.Sprintf("-- %s\n", p.Name))
	if p.Description != "" {
		result.WriteString(fmt.Sprintf("-- %s\n", p.Description))
	}
	result.WriteString("-- Generated by nvim-manager\n\n")
	result.WriteString(luaCode)

	return result.String(), nil
}

// writeStringOrArray writes a Lua field that can be a string or array.
func (g *Generator) writeStringOrArray(lua *strings.Builder, indent, field string, values []string) {
	if len(values) == 1 {
		lua.WriteString(fmt.Sprintf("%s%s = \"%s\",\n", indent, field, escapeString(values[0])))
	} else {
		lua.WriteString(fmt.Sprintf("%s%s = { ", indent, field))
		for i, v := range values {
			if i > 0 {
				lua.WriteString(", ")
			}
			lua.WriteString(fmt.Sprintf("\"%s\"", escapeString(v)))
		}
		lua.WriteString(" },\n")
	}
}

// writeDependencies writes the dependencies table.
func (g *Generator) writeDependencies(lua *strings.Builder, indent string, deps []Dependency) {
	lua.WriteString(fmt.Sprintf("%sdependencies = {\n", indent))
	indent2 := indent + strings.Repeat(" ", g.IndentSize)

	for _, dep := range deps {
		if dep.Build == "" && dep.Version == "" && dep.Branch == "" && !dep.Config {
			// Simple dependency
			lua.WriteString(fmt.Sprintf("%s\"%s\",\n", indent2, dep.Repo))
		} else {
			// Complex dependency
			lua.WriteString(fmt.Sprintf("%s{ \"%s\"", indent2, dep.Repo))
			if dep.Build != "" {
				lua.WriteString(fmt.Sprintf(", build = \"%s\"", escapeString(dep.Build)))
			}
			if dep.Version != "" {
				lua.WriteString(fmt.Sprintf(", version = \"%s\"", escapeString(dep.Version)))
			}
			if dep.Branch != "" {
				lua.WriteString(fmt.Sprintf(", branch = \"%s\"", escapeString(dep.Branch)))
			}
			if dep.Config {
				lua.WriteString(", config = true")
			}
			lua.WriteString(" },\n")
		}
	}

	lua.WriteString(fmt.Sprintf("%s},\n", indent))
}

// writeKeys writes the keys table for lazy loading.
func (g *Generator) writeKeys(lua *strings.Builder, indent string, keys []Keymap) {
	lua.WriteString(fmt.Sprintf("%skeys = {\n", indent))
	indent2 := indent + strings.Repeat(" ", g.IndentSize)

	for _, key := range keys {
		lua.WriteString(fmt.Sprintf("%s{ \"%s\"", indent2, escapeString(key.Key)))

		// Action
		if key.Action != "" {
			// Check if action is a Lua expression (starts with require or function)
			if isLuaExpression(key.Action) {
				lua.WriteString(fmt.Sprintf(", %s", key.Action))
			} else {
				lua.WriteString(fmt.Sprintf(", \"%s\"", escapeString(key.Action)))
			}
		}

		// Description
		if key.Desc != "" {
			lua.WriteString(fmt.Sprintf(", desc = \"%s\"", escapeString(key.Desc)))
		}

		// Mode
		if len(key.Mode) > 0 {
			if len(key.Mode) == 1 {
				lua.WriteString(fmt.Sprintf(", mode = \"%s\"", key.Mode[0]))
			} else {
				lua.WriteString(", mode = { ")
				for i, m := range key.Mode {
					if i > 0 {
						lua.WriteString(", ")
					}
					lua.WriteString(fmt.Sprintf("\"%s\"", m))
				}
				lua.WriteString(" }")
			}
		}

		lua.WriteString(" },\n")
	}

	lua.WriteString(fmt.Sprintf("%s},\n", indent))
}

// writeFunction writes an init or config function.
func (g *Generator) writeFunction(lua *strings.Builder, indent, funcName, code string) {
	lua.WriteString(fmt.Sprintf("%s%s = function()\n", indent, funcName))

	// Indent each line of the code
	lines := strings.Split(code, "\n")
	funcIndent := indent + strings.Repeat(" ", g.IndentSize)
	for _, line := range lines {
		trimmed := strings.TrimRight(line, " \t")
		if trimmed != "" {
			lua.WriteString(funcIndent + trimmed + "\n")
		}
	}

	lua.WriteString(fmt.Sprintf("%send,\n", indent))
}

// writeOpts writes the opts table.
func (g *Generator) writeOpts(lua *strings.Builder, indent string, opts map[string]interface{}) {
	// For complex opts, use JSON encoding as a base and convert to Lua
	// This is a simplified approach - for production, you'd want proper Lua table generation
	optsJSON, err := json.MarshalIndent(opts, indent, strings.Repeat(" ", g.IndentSize))
	if err != nil {
		// Fallback to empty opts on error
		lua.WriteString(fmt.Sprintf("%sopts = {},\n", indent))
		return
	}

	// Convert JSON to Lua-style table
	luaOpts := jsonToLua(string(optsJSON))
	lua.WriteString(fmt.Sprintf("%sopts = %s,\n", indent, luaOpts))
}

// escapeString escapes special characters in a Lua string.
func escapeString(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	s = strings.ReplaceAll(s, "\n", "\\n")
	s = strings.ReplaceAll(s, "\r", "\\r")
	s = strings.ReplaceAll(s, "\t", "\\t")
	return s
}

// isLuaExpression checks if a string looks like a Lua expression.
func isLuaExpression(s string) bool {
	s = strings.TrimSpace(s)
	return strings.HasPrefix(s, "require(") ||
		strings.HasPrefix(s, "require'") ||
		strings.HasPrefix(s, "require \"") ||
		strings.HasPrefix(s, "function") ||
		strings.HasPrefix(s, "<cmd>") // Vim command
}

// jsonToLua converts a JSON string to a Lua table string.
func jsonToLua(json string) string {
	// Basic conversions
	lua := json
	lua = strings.ReplaceAll(lua, ":", " =") // JSON : to Lua =
	lua = strings.ReplaceAll(lua, "[", "{")  // JSON array to Lua table
	lua = strings.ReplaceAll(lua, "]", "}")  // JSON array to Lua table
	lua = strings.ReplaceAll(lua, "null", "nil")
	lua = strings.ReplaceAll(lua, "true", "true")   // same in both
	lua = strings.ReplaceAll(lua, "false", "false") // same in both
	return lua
}
