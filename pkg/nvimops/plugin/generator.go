package plugin

import (
	"fmt"
	"strings"
)

// Generator converts Plugin definitions to Lua code for lazy.nvim.
type Generator struct {
	// IndentSize is the number of spaces per indentation level (default: 2)
	IndentSize int
}

// NewGenerator creates a new Lua generator with default settings.
func NewGenerator() *Generator {
	return &Generator{
		IndentSize: 2,
	}
}

// GenerateLua converts a Plugin to lazy.nvim compatible Lua code.
func (g *Generator) GenerateLua(p *Plugin) (string, error) {
	var lua strings.Builder
	indent := strings.Repeat(" ", g.IndentSize)

	// Start the plugin spec
	lua.WriteString("return {\n")
	lua.WriteString(fmt.Sprintf("%s\"%s\",\n", indent, p.Repo))

	// Branch
	if p.Branch != "" {
		lua.WriteString(fmt.Sprintf("%sbranch = \"%s\",\n", indent, p.Branch))
	}

	// Version (tag)
	if p.Version != "" {
		lua.WriteString(fmt.Sprintf("%sversion = \"%s\",\n", indent, p.Version))
	}

	// Priority
	if p.Priority != 0 {
		lua.WriteString(fmt.Sprintf("%spriority = %d,\n", indent, p.Priority))
	}

	// Event (lazy loading trigger)
	if len(p.Event) > 0 {
		g.writeStringOrArray(&lua, indent, "event", p.Event)
	}

	// Filetype
	if len(p.Ft) > 0 {
		g.writeStringOrArray(&lua, indent, "ft", p.Ft)
	}

	// Command
	if len(p.Cmd) > 0 {
		g.writeStringOrArray(&lua, indent, "cmd", p.Cmd)
	}

	// Dependencies
	if len(p.Dependencies) > 0 {
		g.writeDependencies(&lua, indent, p.Dependencies)
	}

	// Keys (lazy loading triggers)
	if len(p.Keys) > 0 {
		g.writeKeys(&lua, indent, p.Keys)
	}

	// Build command
	if p.Build != "" {
		if isLuaExpression(p.Build) {
			lua.WriteString(fmt.Sprintf("%sbuild = %s,\n", indent, p.Build))
		} else {
			lua.WriteString(fmt.Sprintf("%sbuild = \"%s\",\n", indent, escapeString(p.Build)))
		}
	}

	// Init function (runs before plugin loads)
	if p.Init != "" {
		g.writeFunction(&lua, indent, "init", p.Init)
	}

	// Config function (runs after plugin loads)
	// If there are keymaps, we need to generate a config function that sets them up
	if p.Config != "" || len(p.Keymaps) > 0 {
		// Handle "true" as Lua boolean (config = true means use default setup)
		if p.Config == "true" && len(p.Keymaps) == 0 {
			lua.WriteString(fmt.Sprintf("%sconfig = true,\n", indent))
		} else {
			// Build the config code combining existing config and keymaps
			configCode := p.Config
			if len(p.Keymaps) > 0 {
				keymapCode := g.generateKeymapCode(p.Keymaps)
				if configCode != "" {
					configCode = configCode + "\n\n" + keymapCode
				} else {
					configCode = keymapCode
				}
			}
			g.writeFunction(&lua, indent, "config", configCode)
		}
	}

	// Opts (passed to plugin.setup())
	if len(p.Opts) > 0 {
		g.writeOpts(&lua, indent, p.Opts)
	}

	lua.WriteString("}\n")

	return lua.String(), nil
}

// GenerateLuaFile generates Lua and includes a header comment.
func (g *Generator) GenerateLuaFile(p *Plugin) (string, error) {
	luaCode, err := g.GenerateLua(p)
	if err != nil {
		return "", err
	}

	var result strings.Builder
	result.WriteString(fmt.Sprintf("-- %s\n", p.Name))
	if p.Description != "" {
		result.WriteString(fmt.Sprintf("-- %s\n", p.Description))
	}
	result.WriteString("-- Generated by nvim-manager\n\n")
	result.WriteString(luaCode)

	return result.String(), nil
}

// writeStringOrArray writes a Lua field that can be a string or array.
func (g *Generator) writeStringOrArray(lua *strings.Builder, indent, field string, values []string) {
	if len(values) == 1 {
		lua.WriteString(fmt.Sprintf("%s%s = \"%s\",\n", indent, field, escapeString(values[0])))
	} else {
		lua.WriteString(fmt.Sprintf("%s%s = { ", indent, field))
		for i, v := range values {
			if i > 0 {
				lua.WriteString(", ")
			}
			lua.WriteString(fmt.Sprintf("\"%s\"", escapeString(v)))
		}
		lua.WriteString(" },\n")
	}
}

// writeDependencies writes the dependencies table.
func (g *Generator) writeDependencies(lua *strings.Builder, indent string, deps []Dependency) {
	lua.WriteString(fmt.Sprintf("%sdependencies = {\n", indent))
	indent2 := indent + strings.Repeat(" ", g.IndentSize)

	for _, dep := range deps {
		if dep.Build == "" && dep.Version == "" && dep.Branch == "" && !dep.Config {
			// Simple dependency
			lua.WriteString(fmt.Sprintf("%s\"%s\",\n", indent2, dep.Repo))
		} else {
			// Complex dependency
			lua.WriteString(fmt.Sprintf("%s{ \"%s\"", indent2, dep.Repo))
			if dep.Build != "" {
				lua.WriteString(fmt.Sprintf(", build = \"%s\"", escapeString(dep.Build)))
			}
			if dep.Version != "" {
				lua.WriteString(fmt.Sprintf(", version = \"%s\"", escapeString(dep.Version)))
			}
			if dep.Branch != "" {
				lua.WriteString(fmt.Sprintf(", branch = \"%s\"", escapeString(dep.Branch)))
			}
			if dep.Config {
				lua.WriteString(", config = true")
			}
			lua.WriteString(" },\n")
		}
	}

	lua.WriteString(fmt.Sprintf("%s},\n", indent))
}

// writeKeys writes the keys table for lazy loading.
func (g *Generator) writeKeys(lua *strings.Builder, indent string, keys []Keymap) {
	lua.WriteString(fmt.Sprintf("%skeys = {\n", indent))
	indent2 := indent + strings.Repeat(" ", g.IndentSize)

	for _, key := range keys {
		lua.WriteString(fmt.Sprintf("%s{ \"%s\"", indent2, escapeString(key.Key)))

		// Action
		if key.Action != "" {
			// Check if action is a Lua expression (starts with require or function)
			if isLuaExpression(key.Action) {
				lua.WriteString(fmt.Sprintf(", %s", key.Action))
			} else {
				lua.WriteString(fmt.Sprintf(", \"%s\"", escapeString(key.Action)))
			}
		}

		// Description
		if key.Desc != "" {
			lua.WriteString(fmt.Sprintf(", desc = \"%s\"", escapeString(key.Desc)))
		}

		// Mode
		if len(key.Mode) > 0 {
			if len(key.Mode) == 1 {
				lua.WriteString(fmt.Sprintf(", mode = \"%s\"", key.Mode[0]))
			} else {
				lua.WriteString(", mode = { ")
				for i, m := range key.Mode {
					if i > 0 {
						lua.WriteString(", ")
					}
					lua.WriteString(fmt.Sprintf("\"%s\"", m))
				}
				lua.WriteString(" }")
			}
		}

		lua.WriteString(" },\n")
	}

	lua.WriteString(fmt.Sprintf("%s},\n", indent))
}

// writeFunction writes an init or config function.
func (g *Generator) writeFunction(lua *strings.Builder, indent, funcName, code string) {
	lua.WriteString(fmt.Sprintf("%s%s = function()\n", indent, funcName))

	// Write the config code, preserving its original formatting (tabs, indentation)
	// Only add base indentation to non-empty lines, preserve blank lines
	lines := strings.Split(code, "\n")
	funcIndent := indent + strings.Repeat(" ", g.IndentSize)
	for i, line := range lines {
		trimmedRight := strings.TrimRight(line, " \t")
		if trimmedRight != "" {
			lua.WriteString(funcIndent + trimmedRight + "\n")
		} else if i < len(lines)-1 {
			// Preserve blank lines within the code (but not trailing)
			lua.WriteString("\n")
		}
	}

	lua.WriteString(fmt.Sprintf("%send,\n", indent))
}

// writeOpts writes the opts table.
func (g *Generator) writeOpts(lua *strings.Builder, indent string, opts map[string]interface{}) {
	lua.WriteString(fmt.Sprintf("%sopts = {\n", indent))
	indent2 := indent + strings.Repeat(" ", g.IndentSize)

	for key, value := range opts {
		g.writeOptsValue(lua, indent2, key, value)
	}

	lua.WriteString(fmt.Sprintf("%s},\n", indent))
}

// writeOptsValue writes a single opts key-value pair.
func (g *Generator) writeOptsValue(lua *strings.Builder, indent, key string, value interface{}) {
	switch v := value.(type) {
	case string:
		// Check if it looks like a Lua function
		trimmed := strings.TrimSpace(v)
		if strings.HasPrefix(trimmed, "function") {
			// Write as raw Lua function
			lua.WriteString(fmt.Sprintf("%s%s = %s,\n", indent, key, trimmed))
		} else {
			// Write as quoted string
			lua.WriteString(fmt.Sprintf("%s%s = \"%s\",\n", indent, key, escapeString(v)))
		}
	case bool:
		lua.WriteString(fmt.Sprintf("%s%s = %t,\n", indent, key, v))
	case int, int64, float64:
		lua.WriteString(fmt.Sprintf("%s%s = %v,\n", indent, key, v))
	case []interface{}:
		// Array - check if it contains complex objects (maps)
		hasComplexItems := false
		for _, item := range v {
			if _, isMap := item.(map[string]interface{}); isMap {
				hasComplexItems = true
				break
			}
		}

		if hasComplexItems {
			// Array of tables - format each on its own line
			lua.WriteString(fmt.Sprintf("%s%s = {\n", indent, key))
			indent2 := indent + strings.Repeat(" ", g.IndentSize)
			for _, item := range v {
				if m, ok := item.(map[string]interface{}); ok {
					lua.WriteString(fmt.Sprintf("%s{\n", indent2))
					indent3 := indent2 + strings.Repeat(" ", g.IndentSize)
					for k, val := range m {
						g.writeOptsValue(lua, indent3, k, val)
					}
					lua.WriteString(fmt.Sprintf("%s},\n", indent2))
				} else if str, ok := item.(string); ok {
					lua.WriteString(fmt.Sprintf("%s\"%s\",\n", indent2, escapeString(str)))
				} else {
					lua.WriteString(fmt.Sprintf("%s%v,\n", indent2, item))
				}
			}
			lua.WriteString(fmt.Sprintf("%s},\n", indent))
		} else {
			// Simple array - inline format
			lua.WriteString(fmt.Sprintf("%s%s = { ", indent, key))
			for i, item := range v {
				if i > 0 {
					lua.WriteString(", ")
				}
				if str, ok := item.(string); ok {
					lua.WriteString(fmt.Sprintf("\"%s\"", escapeString(str)))
				} else {
					lua.WriteString(fmt.Sprintf("%v", item))
				}
			}
			lua.WriteString(" },\n")
		}
	case map[string]interface{}:
		// Nested table
		lua.WriteString(fmt.Sprintf("%s%s = {\n", indent, key))
		indent2 := indent + strings.Repeat(" ", g.IndentSize)
		for k, val := range v {
			g.writeOptsValue(lua, indent2, k, val)
		}
		lua.WriteString(fmt.Sprintf("%s},\n", indent))
	default:
		// Fallback: convert to string
		lua.WriteString(fmt.Sprintf("%s%s = \"%v\",\n", indent, key, value))
	}
}

// generateKeymapCode generates vim.keymap.set() calls for keymaps.
// This is used for additional keymaps that should be set up in the config function.
func (g *Generator) generateKeymapCode(keymaps []Keymap) string {
	var lines []string
	lines = append(lines, "-- Keymaps")

	for _, km := range keymaps {
		// Determine mode(s)
		mode := "n" // Default to normal mode
		if len(km.Mode) == 1 {
			mode = fmt.Sprintf("\"%s\"", km.Mode[0])
		} else if len(km.Mode) > 1 {
			modes := make([]string, len(km.Mode))
			for i, m := range km.Mode {
				modes[i] = fmt.Sprintf("\"%s\"", m)
			}
			mode = "{ " + strings.Join(modes, ", ") + " }"
		} else {
			mode = "\"n\""
		}

		// Build the action
		action := km.Action
		if action == "" {
			continue // Skip keymaps without actions
		}

		// Check if action is a Lua expression
		if !isLuaExpression(action) {
			action = fmt.Sprintf("\"%s\"", escapeString(action))
		}

		// Build the opts table
		opts := "{ "
		if km.Desc != "" {
			opts += fmt.Sprintf("desc = \"%s\", ", escapeString(km.Desc))
		}
		opts += "silent = true, noremap = true }"

		line := fmt.Sprintf("vim.keymap.set(%s, \"%s\", %s, %s)",
			mode, escapeString(km.Key), action, opts)
		lines = append(lines, line)
	}

	return strings.Join(lines, "\n")
}

// escapeString escapes special characters in a Lua string.
func escapeString(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	s = strings.ReplaceAll(s, "\n", "\\n")
	s = strings.ReplaceAll(s, "\r", "\\r")
	s = strings.ReplaceAll(s, "\t", "\\t")
	return s
}

// isLuaExpression checks if a string looks like a Lua expression.
func isLuaExpression(s string) bool {
	s = strings.TrimSpace(s)
	return strings.HasPrefix(s, "require(") ||
		strings.HasPrefix(s, "require'") ||
		strings.HasPrefix(s, "require \"") ||
		strings.HasPrefix(s, "function")
	// Note: <cmd>...<cr> is NOT a Lua expression, it's a string
}
