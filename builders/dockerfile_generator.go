package builders

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"devopsmaestro/models"
	"devopsmaestro/utils"
)

// DockerfileGenerator generates Dockerfiles for dev containers
type DockerfileGenerator struct {
	workspace      *models.Workspace
	workspaceYAML  models.WorkspaceSpec
	language       string
	version        string
	appPath        string
	baseDockerfile string
}

// NewDockerfileGenerator creates a new Dockerfile generator
func NewDockerfileGenerator(ws *models.Workspace, wsYAML models.WorkspaceSpec, lang, version, appPath, baseDockerfile string) *DockerfileGenerator {
	return &DockerfileGenerator{
		workspace:      ws,
		workspaceYAML:  wsYAML,
		language:       lang,
		version:        version,
		appPath:        appPath,
		baseDockerfile: baseDockerfile,
	}
}

// Generate creates a Dockerfile.dvm with dev stage
func (g *DockerfileGenerator) Generate() (string, error) {
	var dockerfile strings.Builder

	// Header comment
	dockerfile.WriteString("# Generated by DevOpsMaestro\n")
	dockerfile.WriteString("# Development container with tools for coding\n\n")

	// Detect private repository usage
	privateRepoInfo := utils.DetectPrivateRepos(g.appPath, g.language)

	// Add ARG declarations for build-time variables
	if len(privateRepoInfo.RequiredBuildArgs) > 0 {
		dockerfile.WriteString("# Build arguments for private repositories\n")
		for _, arg := range privateRepoInfo.RequiredBuildArgs {
			dockerfile.WriteString(fmt.Sprintf("ARG %s\n", arg))
		}
		dockerfile.WriteString("\n")
	}

	// For MVP: Always generate from scratch
	// Future: Support extending existing production Dockerfiles
	g.generateBaseStage(&dockerfile, privateRepoInfo)

	// Dev stage
	dockerfile.WriteString("# Development stage with additional tools\n")
	dockerfile.WriteString("FROM base AS dev\n\n")

	// Switch to root for installing dev tools
	dockerfile.WriteString("USER root\n\n")

	// Generate dev stage content based on language and config
	g.generateDevStage(&dockerfile)

	// Create dev user if not exists
	g.generateDevUser(&dockerfile)

	// Add Neovim configuration after user is created
	g.generateNvimSection(&dockerfile)

	// Switch to dev user
	dockerfile.WriteString("USER dev\n\n")

	// Set working directory
	workdir := g.workspaceYAML.Container.WorkingDir
	if workdir == "" {
		workdir = "/workspace"
	}
	dockerfile.WriteString(fmt.Sprintf("WORKDIR %s\n\n", workdir))

	// Set command
	if len(g.workspaceYAML.Container.Command) > 0 {
		cmd := strings.Join(g.workspaceYAML.Container.Command, "\", \"")
		dockerfile.WriteString(fmt.Sprintf("CMD [\"%s\"]\n", cmd))
	} else {
		// Default to a long-running process
		dockerfile.WriteString("CMD [\"/bin/zsh\", \"-c\", \"tail -f /dev/null\"]\n")
	}

	return dockerfile.String(), nil
}

func (g *DockerfileGenerator) generateBaseStage(dockerfile *strings.Builder, privateRepoInfo *utils.PrivateRepoInfo) {
	dockerfile.WriteString("# Base stage (auto-generated)\n")

	switch g.language {
	case "python":
		version := g.version
		if version == "" {
			version = "3.11"
		}
		dockerfile.WriteString(fmt.Sprintf("FROM python:%s-slim AS base\n\n", version))

		// Install git if needed for private repos
		if privateRepoInfo.NeedsGit {
			packages := []string{"git", "gcc", "python3-dev"}
			if privateRepoInfo.NeedsSSH {
				packages = append(packages, "openssh-client")
			}

			dockerfile.WriteString("# Install git for private repositories\n")
			dockerfile.WriteString("RUN apt-get update && apt-get install -y --no-install-recommends \\\n")
			for i, pkg := range packages {
				if i < len(packages)-1 {
					dockerfile.WriteString(fmt.Sprintf("    %s \\\n", pkg))
				} else {
					dockerfile.WriteString(fmt.Sprintf("    %s \\\n", pkg))
				}
			}
			dockerfile.WriteString("    && rm -rf /var/lib/apt/lists/*\n\n")

			// Setup SSH for git if needed
			if privateRepoInfo.NeedsSSH {
				dockerfile.WriteString("# Setup SSH for git operations\n")
				dockerfile.WriteString("RUN mkdir -p /root/.ssh && chmod 700 /root/.ssh\n")
				dockerfile.WriteString("# Mount SSH keys at build time using BuildKit secrets:\n")
				dockerfile.WriteString("# --mount=type=ssh\n")
				dockerfile.WriteString("RUN --mount=type=ssh \\\n")
				dockerfile.WriteString("    ssh-keyscan github.com >> /root/.ssh/known_hosts && \\\n")
				dockerfile.WriteString("    ssh-keyscan gitlab.com >> /root/.ssh/known_hosts\n\n")
			}
		} else {
			dockerfile.WriteString("# Install basic dependencies\n")
			dockerfile.WriteString("RUN apt-get update && apt-get install -y --no-install-recommends \\\n")
			dockerfile.WriteString("    gcc \\\n")
			dockerfile.WriteString("    python3-dev \\\n")
			dockerfile.WriteString("    && rm -rf /var/lib/apt/lists/*\n\n")
		}

		// For Python with SSH keys, install deps with SSH mount
		if privateRepoInfo.NeedsSSH {
			dockerfile.WriteString("# Install dependencies with SSH key mount\n")
			dockerfile.WriteString("COPY requirements.txt /tmp/\n")
			dockerfile.WriteString("RUN --mount=type=ssh \\\n")
			dockerfile.WriteString("    pip install --no-cache-dir -r /tmp/requirements.txt\n\n")
		} else if len(privateRepoInfo.RequiredBuildArgs) > 0 {
			dockerfile.WriteString("# Copy and process requirements with build args\n")
			dockerfile.WriteString("COPY requirements.txt /tmp/requirements-template.txt\n")

			// Use shell to substitute variables
			dockerfile.WriteString("RUN cat /tmp/requirements-template.txt | \\\n")
			for _, arg := range privateRepoInfo.RequiredBuildArgs {
				dockerfile.WriteString(fmt.Sprintf("    sed \"s/\\${%s}/$%s/g\" | \\\n", arg, arg))
			}
			dockerfile.WriteString("    tee /tmp/requirements.txt > /dev/null\n\n")

			dockerfile.WriteString("RUN pip install --no-cache-dir -r /tmp/requirements.txt\n\n")
		} else {
			dockerfile.WriteString("# Copy requirements and install\n")
			dockerfile.WriteString("COPY requirements.txt /tmp/\n")
			dockerfile.WriteString("RUN pip install --no-cache-dir -r /tmp/requirements.txt\n\n")
		}

	case "golang":
		version := g.version
		if version == "" {
			version = "1.22"
		}
		dockerfile.WriteString(fmt.Sprintf("FROM golang:%s-alpine AS base\n\n", version))

		dockerfile.WriteString("# Install basic dependencies\n")
		dockerfile.WriteString("RUN apk add --no-cache git\n\n")

		// Configure git for private repos with token
		if privateRepoInfo.NeedsGitConfig {
			dockerfile.WriteString("# Configure git for private repositories\n")
			for _, arg := range privateRepoInfo.RequiredBuildArgs {
				if arg == "GITHUB_TOKEN" {
					dockerfile.WriteString(fmt.Sprintf("ARG %s\n", arg))
					dockerfile.WriteString("RUN git config --global url.\"https://${GITHUB_TOKEN}@github.com/\".insteadOf \"https://github.com/\"\n\n")
				}
			}
		}

	case "nodejs":
		version := g.version
		if version == "" {
			version = "18"
		}
		dockerfile.WriteString(fmt.Sprintf("FROM node:%s-alpine AS base\n\n", version))

		if privateRepoInfo.NeedsGit {
			dockerfile.WriteString("# Install git for private repositories\n")
			dockerfile.WriteString("RUN apk add --no-cache git\n\n")
		}

		// Setup .npmrc for private packages
		if len(privateRepoInfo.RequiredBuildArgs) > 0 {
			dockerfile.WriteString("# Configure npm for private packages\n")
			for _, arg := range privateRepoInfo.RequiredBuildArgs {
				if arg == "NPM_TOKEN" {
					dockerfile.WriteString(fmt.Sprintf("ARG %s\n", arg))
					dockerfile.WriteString("RUN echo \"//registry.npmjs.org/:_authToken=${NPM_TOKEN}\" > ~/.npmrc\n\n")
				}
			}
		}

	default:
		// Generic Ubuntu base
		dockerfile.WriteString("FROM ubuntu:22.04 AS base\n\n")

		packages := []string{"ca-certificates"}
		if privateRepoInfo.NeedsGit {
			packages = append(packages, "git")
		}

		dockerfile.WriteString("RUN apt-get update && apt-get install -y --no-install-recommends \\\n")
		for i, pkg := range packages {
			if i < len(packages)-1 {
				dockerfile.WriteString(fmt.Sprintf("    %s \\\n", pkg))
			} else {
				dockerfile.WriteString(fmt.Sprintf("    %s \\\n", pkg))
			}
		}
		dockerfile.WriteString("    && rm -rf /var/lib/apt/lists/*\n\n")
	}
}

func (g *DockerfileGenerator) generateDevStage(dockerfile *strings.Builder) {
	// Get packages from config or use defaults
	packages := g.workspaceYAML.Build.DevStage.Packages
	if len(packages) == 0 {
		packages = g.getDefaultPackages()
	}

	languageTools := g.workspaceYAML.Build.DevStage.DevTools
	if len(languageTools) == 0 {
		languageTools = g.getDefaultLanguageTools()
	}

	// Detect package manager
	var pkgManager, updateCmd, installCmd string
	if g.language == "golang" || strings.Contains(g.workspace.ImageName, "alpine") {
		pkgManager = "apk"
		updateCmd = "apk update"
		installCmd = "apk add --no-cache"
	} else {
		pkgManager = "apt"
		updateCmd = "apt-get update"
		installCmd = "apt-get install -y --no-install-recommends"
	}

	// Install dev packages
	dockerfile.WriteString("# Install dev tools\n")
	dockerfile.WriteString(fmt.Sprintf("RUN %s && %s \\\n", updateCmd, installCmd))

	for i, pkg := range packages {
		if i < len(packages)-1 {
			dockerfile.WriteString(fmt.Sprintf("    %s \\\n", pkg))
		} else {
			dockerfile.WriteString(fmt.Sprintf("    %s", pkg))
		}
	}

	if pkgManager == "apt" {
		dockerfile.WriteString(" \\\n    && rm -rf /var/lib/apt/lists/*\n\n")
	} else {
		dockerfile.WriteString("\n\n")
	}

	// Install Neovim from GitHub releases before other tools
	g.installNeovim(dockerfile)

	// Install language-specific tools
	if len(languageTools) > 0 {
		g.installLanguageTools(dockerfile, languageTools)
	}

	// Install Starship prompt (ARM64 compatible)
	if g.workspaceYAML.Shell.Theme == "starship" || g.workspaceYAML.Shell.Theme == "" {
		dockerfile.WriteString("# Install Starship prompt\n")
		dockerfile.WriteString("RUN curl -sS https://starship.rs/install.sh | sh -s -- --yes\n\n")
	}

	// Install Neovim dependencies (but don't copy config yet - user doesn't exist)
	g.installNvimDependencies(dockerfile)

	// Custom commands
	for _, cmd := range g.workspaceYAML.Build.DevStage.CustomCommands {
		dockerfile.WriteString(fmt.Sprintf("RUN %s\n", cmd))
	}

	if len(g.workspaceYAML.Build.DevStage.CustomCommands) > 0 {
		dockerfile.WriteString("\n")
	}
}

func (g *DockerfileGenerator) generateDevUser(dockerfile *strings.Builder) {
	uid := g.workspaceYAML.Container.UID
	gid := g.workspaceYAML.Container.GID
	user := g.workspaceYAML.Container.User

	if uid == 0 {
		uid = 1000
	}
	if gid == 0 {
		gid = 1000
	}
	if user == "" {
		user = "dev"
	}

	dockerfile.WriteString("# Create dev user\n")
	dockerfile.WriteString(fmt.Sprintf("RUN groupadd -g %d %s || true\n", gid, user))
	dockerfile.WriteString(fmt.Sprintf("RUN useradd -m -u %d -g %d -s /bin/zsh %s || true\n\n", uid, gid, user))

	// Copy shell configuration files from staging area
	dockerfile.WriteString("# Copy shell configuration\n")
	dockerfile.WriteString("COPY .zshrc /home/dev/.zshrc\n")
	dockerfile.WriteString("COPY .config/starship.toml /home/dev/.config/starship.toml\n")
	dockerfile.WriteString("RUN chown -R dev:dev /home/dev/.zshrc /home/dev/.config\n\n")
}

func (g *DockerfileGenerator) getDefaultPackages() []string {
	base := []string{
		"git",
		"curl",
		"wget",
		"zsh",
	}

	// Add language-specific base packages
	switch g.language {
	case "python":
		if !strings.Contains(g.workspace.ImageName, "alpine") {
			base = append(base, "build-essential", "python3-pip")
		}
	case "golang":
		// Go images usually have everything needed
	}

	return base
}

// installNeovim installs Neovim from GitHub releases (works on all base images)
func (g *DockerfileGenerator) installNeovim(dockerfile *strings.Builder) {
	dockerfile.WriteString("# Install Neovim from GitHub releases\n")

	// Detect if this is an Alpine-based image
	isAlpine := g.language == "golang" || strings.Contains(g.workspace.ImageName, "alpine")

	if isAlpine {
		// Alpine uses uname -m for architecture detection
		dockerfile.WriteString("RUN ARCH=$(uname -m) && \\\n")
		dockerfile.WriteString("    if [ \"$ARCH\" = \"aarch64\" ]; then \\\n")
		dockerfile.WriteString("        NVIM_ARCH=\"nvim-linux-arm64\"; \\\n")
		dockerfile.WriteString("    elif [ \"$ARCH\" = \"x86_64\" ]; then \\\n")
		dockerfile.WriteString("        NVIM_ARCH=\"nvim-linux-x86_64\"; \\\n")
		dockerfile.WriteString("    else \\\n")
		dockerfile.WriteString("        NVIM_ARCH=\"nvim-linux-x86_64\"; \\\n")
		dockerfile.WriteString("    fi && \\\n")
	} else {
		// Debian/Ubuntu uses dpkg architecture detection with fallback to uname
		dockerfile.WriteString("RUN ARCH=$(dpkg --print-architecture 2>/dev/null || uname -m) && \\\n")
		dockerfile.WriteString("    if [ \"$ARCH\" = \"arm64\" ] || [ \"$ARCH\" = \"aarch64\" ]; then \\\n")
		dockerfile.WriteString("        NVIM_ARCH=\"nvim-linux-arm64\"; \\\n")
		dockerfile.WriteString("    elif [ \"$ARCH\" = \"amd64\" ] || [ \"$ARCH\" = \"x86_64\" ]; then \\\n")
		dockerfile.WriteString("        NVIM_ARCH=\"nvim-linux-x86_64\"; \\\n")
		dockerfile.WriteString("    else \\\n")
		dockerfile.WriteString("        NVIM_ARCH=\"nvim-linux-x86_64\"; \\\n")
		dockerfile.WriteString("    fi && \\\n")
	}

	// Download and install Neovim
	dockerfile.WriteString("    curl -LO \"https://github.com/neovim/neovim/releases/latest/download/${NVIM_ARCH}.tar.gz\" && \\\n")
	dockerfile.WriteString("    tar -C /opt -xzf \"${NVIM_ARCH}.tar.gz\" && \\\n")
	dockerfile.WriteString("    ln -sf \"/opt/${NVIM_ARCH}/bin/nvim\" /usr/local/bin/nvim && \\\n")
	dockerfile.WriteString("    rm \"${NVIM_ARCH}.tar.gz\"\n\n")
}

func (g *DockerfileGenerator) getDefaultLanguageTools() []string {
	switch g.language {
	case "python":
		return []string{"python-lsp-server", "black", "isort", "pytest"}
	case "golang":
		return []string{"gopls", "delve", "golangci-lint"}
	case "nodejs":
		return []string{"typescript", "ts-node"}
	default:
		return []string{}
	}
}

func (g *DockerfileGenerator) installLanguageTools(dockerfile *strings.Builder, tools []string) {
	dockerfile.WriteString("# Install language-specific tools\n")

	switch g.language {
	case "python":
		dockerfile.WriteString("RUN pip install --no-cache-dir")
		for _, tool := range tools {
			dockerfile.WriteString(fmt.Sprintf(" %s", tool))
		}
		dockerfile.WriteString("\n\n")

	case "golang":
		for _, tool := range tools {
			var installCmd string
			switch tool {
			case "gopls":
				installCmd = "go install golang.org/x/tools/gopls@latest"
			case "delve":
				installCmd = "go install github.com/go-delve/delve/cmd/dlv@latest"
			case "golangci-lint":
				installCmd = "curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin"
			default:
				installCmd = fmt.Sprintf("go install %s@latest", tool)
			}
			dockerfile.WriteString(fmt.Sprintf("RUN %s\n", installCmd))
		}
		dockerfile.WriteString("\n")

	case "nodejs":
		dockerfile.WriteString("RUN npm install -g")
		for _, tool := range tools {
			dockerfile.WriteString(fmt.Sprintf(" %s", tool))
		}
		dockerfile.WriteString("\n\n")
	}
}

// installNvimDependencies installs packages needed for Neovim
func (g *DockerfileGenerator) installNvimDependencies(dockerfile *strings.Builder) {
	// Check if nvim config is requested (structure field must be set)
	if g.workspaceYAML.Nvim.Structure == "" {
		// Default behavior: install full workspace config
		g.workspaceYAML.Nvim.Structure = "custom"
	}

	// Skip if explicitly disabled
	if g.workspaceYAML.Nvim.Structure == "none" {
		return
	}

	dockerfile.WriteString("# Install Neovim dependencies\n")

	// Detect if this is an Alpine-based image
	isAlpine := g.language == "golang" || strings.Contains(g.workspace.ImageName, "alpine")

	if isAlpine {
		dockerfile.WriteString("RUN apk add --no-cache \\\n")
		dockerfile.WriteString("    unzip \\\n")
		dockerfile.WriteString("    build-base \\\n")
		dockerfile.WriteString("    ripgrep \\\n")
		dockerfile.WriteString("    fd\n\n")
	} else {
		dockerfile.WriteString("RUN apt-get update && apt-get install -y --no-install-recommends \\\n")
		dockerfile.WriteString("    unzip \\\n")
		dockerfile.WriteString("    build-essential \\\n")
		dockerfile.WriteString("    ripgrep \\\n")
		dockerfile.WriteString("    fd-find \\\n")
		dockerfile.WriteString("    && rm -rf /var/lib/apt/lists/*\n\n")
	}
}

// generateNvimSection copies nvim config and installs plugins (called after user creation)
func (g *DockerfileGenerator) generateNvimSection(dockerfile *strings.Builder) {
	// Skip if explicitly disabled
	if g.workspaceYAML.Nvim.Structure == "none" {
		return
	}

	// Check if staging nvim config directory exists
	// The copyNvimConfig function now creates config in staging directory
	homeDir, _ := os.UserHomeDir()
	stagingDir := filepath.Join(homeDir, ".devopsmaestro", "build-staging", filepath.Base(g.appPath))
	nvimConfigPath := filepath.Join(stagingDir, ".config", "nvim")
	if _, err := os.Stat(nvimConfigPath); os.IsNotExist(err) {
		// Nvim config doesn't exist - skip this section
		dockerfile.WriteString("# Skipping Neovim configuration (no config generated)\n")
		dockerfile.WriteString("# Run 'dvm build' after setting up nvim plugins to enable nvim config\n\n")
		return
	}

	// Copy nvim configuration from staging directory
	dockerfile.WriteString("# Copy Neovim configuration\n")
	dockerfile.WriteString("COPY .config/nvim /home/dev/.config/nvim\n")
	dockerfile.WriteString("RUN chown -R dev:dev /home/dev/.config\n\n")

	// Install lazy.nvim and plugins as dev user with proper error handling
	dockerfile.WriteString("USER dev\n")
	dockerfile.WriteString("# Bootstrap lazy.nvim and install plugins\n")
	dockerfile.WriteString("RUN nvim --headless \"+Lazy! sync\" +qa 2>&1 | tee /tmp/nvim-install.log || \\\n")
	dockerfile.WriteString("    (cat /tmp/nvim-install.log && exit 1)\n\n")
	dockerfile.WriteString("USER root\n\n")
}

// installNvimConfig adds commands to install and configure Neovim with the full setup
// DEPRECATED: Split into installNvimDependencies and generateNvimSection
func (g *DockerfileGenerator) installNvimConfig(dockerfile *strings.Builder) {
	// Check if nvim config is requested (structure field must be set)
	if g.workspaceYAML.Nvim.Structure == "" {
		// Default behavior: install full workspace config
		g.workspaceYAML.Nvim.Structure = "custom"
	}

	// Skip if explicitly disabled
	if g.workspaceYAML.Nvim.Structure == "none" {
		return
	}

	dockerfile.WriteString("# Install Neovim dependencies\n")
	dockerfile.WriteString("RUN apt-get update && apt-get install -y --no-install-recommends \\\n")
	dockerfile.WriteString("    unzip \\\n")
	dockerfile.WriteString("    build-essential \\\n")
	dockerfile.WriteString("    ripgrep \\\n")
	dockerfile.WriteString("    fd-find \\\n")
	dockerfile.WriteString("    && rm -rf /var/lib/apt/lists/*\n\n")

	// Copy nvim configuration
	dockerfile.WriteString("# Copy Neovim configuration\n")
	dockerfile.WriteString("COPY .config/nvim /home/dev/.config/nvim\n")
	dockerfile.WriteString("RUN chown -R dev:dev /home/dev/.config\n\n")

	// Install lazy.nvim and plugins as dev user
	dockerfile.WriteString("USER dev\n")
	dockerfile.WriteString("# Bootstrap lazy.nvim and install plugins\n")
	dockerfile.WriteString("RUN nvim --headless \"+Lazy! sync\" +qa || true\n\n")
	dockerfile.WriteString("USER root\n\n")
}
